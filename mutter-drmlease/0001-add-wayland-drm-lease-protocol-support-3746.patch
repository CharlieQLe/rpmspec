From 6a81d5f0bb5f6b2ea34d1d98ad28a98111096459 Mon Sep 17 00:00:00 2001
From: Robert Mader <robert.mader@collabora.com>
Date: Mon, 22 Apr 2024 11:22:15 +0200
Subject: [PATCH 01/44] wayland/surface: Fix sending preferred buffer transform

Fix an obvious copy paste error that slipped through the cracks.
Fortunately it doesn't have a visual impact for well behaving clients
but only makes us not hit direct-scanout paths, assuming no other bugs
in the stack.

Fixes: f21762ea6e (wayland: Add support for preferred_buffer_scale/transform)
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3717>
---
 src/wayland/meta-wayland-surface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 6dc5006b7..64d94080c 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -2457,7 +2457,7 @@ committed_state_handle_highest_scale_monitor (MetaWaylandSurface *surface)
       transform = meta_wayland_surface_get_output_transform (surface);
       if (transform != surface->preferred_transform)
         {
-          wl_surface_send_preferred_buffer_transform (surface->resource, ceiled_scale);
+          wl_surface_send_preferred_buffer_transform (surface->resource, transform);
           surface->preferred_transform = transform;
         }
     }
-- 
2.45.0


From 669d21daa2eb4a5cfe920fd9c0f7f1451b67551d Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Mon, 22 Apr 2024 08:32:16 +0300
Subject: [PATCH 02/44] x11: Drop obsolete libXrender dependency

It seems only the iconcache used to use it, but this is gone since
commit d16ddc42ceb5b9.
Even before that, the Xrender usage was removed in commit 556e7694de01,
albeit leaving a redundant include <X11/extensions/Xrender.h> in its
place then, which comes from libXrender.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3716>
---
 meson.build     | 1 -
 src/meson.build | 1 -
 2 files changed, 2 deletions(-)

diff --git a/meson.build b/meson.build
index a485ec4b4..50c751263 100644
--- a/meson.build
+++ b/meson.build
@@ -160,7 +160,6 @@ if have_x11_client
   xkbfile_dep = dependency('xkbfile')
   xkeyboard_config_dep = dependency('xkeyboard-config')
   xkbcommon_x11_dep = dependency('xkbcommon-x11')
-  xrender_dep = dependency('xrender')
   x11_xcb_dep = dependency('x11-xcb')
   xrandr_dep = dependency('xrandr', version: xrandr_req)
   xcb_randr_dep = dependency('xcb-randr')
diff --git a/src/meson.build b/src/meson.build
index 05df3bfd2..3060b2880 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -115,7 +115,6 @@ if have_x11
     xkbfile_dep,
     xkeyboard_config_dep,
     xkbcommon_x11_dep,
-    xrender_dep,
     x11_xcb_dep,
     xcb_randr_dep,
     xcb_res_dep,
-- 
2.45.0


From fb8ac5dff757c1bb142d0beacdb0d6314934cac6 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Fri, 19 Apr 2024 19:04:59 +0200
Subject: [PATCH 03/44] wayland: Track current tablet tool focus surface

We did not track the current surface (i.e. the logical focus) too
thoroughly, so there might be chances that a stale surface pointer
here becomes the focus. Track its destruction (like it's done at e.g.
MetaWaylandPointer) and unset the current surface early, in order
to avoid possible invalid memory access.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/3372
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3715>
---
 src/wayland/meta-wayland-tablet-tool.c | 50 ++++++++++++++++++++++----
 1 file changed, 44 insertions(+), 6 deletions(-)

diff --git a/src/wayland/meta-wayland-tablet-tool.c b/src/wayland/meta-wayland-tablet-tool.c
index 5d8338328..c262391f5 100644
--- a/src/wayland/meta-wayland-tablet-tool.c
+++ b/src/wayland/meta-wayland-tablet-tool.c
@@ -64,9 +64,14 @@ struct _MetaWaylandTabletTool
 
   float grab_x, grab_y;
 
+  gulong current_surface_destroyed_handler_id;
+
   MetaWaylandTablet *current_tablet;
 };
 
+static void meta_wayland_tablet_tool_set_current_surface (MetaWaylandTabletTool *tool,
+							  MetaWaylandSurface    *surface);
+
 static MetaBackend *
 backend_from_tool (MetaWaylandTabletTool *tool)
 {
@@ -453,6 +458,7 @@ meta_wayland_tablet_tool_free (MetaWaylandTabletTool *tool)
 {
   struct wl_resource *resource, *next;
 
+  meta_wayland_tablet_tool_set_current_surface (tool, NULL);
   meta_wayland_tablet_tool_set_focus (tool, NULL, NULL);
   meta_wayland_tablet_tool_set_cursor_surface (tool, NULL);
   g_clear_object (&tool->cursor_renderer);
@@ -595,10 +601,41 @@ meta_wayland_tablet_tool_account_button (MetaWaylandTabletTool *tool,
 }
 
 static void
-sync_focus_surface (MetaWaylandTabletTool *tool,
-                    const ClutterEvent    *event)
+current_surface_destroyed (MetaWaylandSurface    *surface,
+                           MetaWaylandTabletTool *tool)
 {
-  meta_wayland_tablet_tool_set_focus (tool, tool->current, event);
+  meta_wayland_tablet_tool_set_current_surface (tool, NULL);
+}
+
+static void
+meta_wayland_tablet_tool_set_current_surface (MetaWaylandTabletTool *tool,
+					      MetaWaylandSurface    *surface)
+{
+  MetaWaylandTabletSeat *tablet_seat;
+  MetaWaylandInput *input;
+
+  if (tool->current == surface)
+    return;
+
+  if (tool->current)
+    {
+      g_clear_signal_handler (&tool->current_surface_destroyed_handler_id,
+                              tool->current);
+      tool->current = NULL;
+    }
+
+  if (surface)
+    {
+      tool->current = surface;
+      tool->current_surface_destroyed_handler_id =
+        g_signal_connect (surface, "destroy",
+                          G_CALLBACK (current_surface_destroyed),
+                          tool);
+    }
+
+  tablet_seat = tool->seat;
+  input = meta_wayland_seat_get_input (tablet_seat->seat);
+  meta_wayland_input_invalidate_focus (input, tool->device, NULL);
 }
 
 static void
@@ -607,6 +644,7 @@ repick_for_event (MetaWaylandTabletTool *tool,
 {
   MetaBackend *backend = backend_from_tool (tool);
   ClutterStage *stage = CLUTTER_STAGE (meta_backend_get_stage (backend));
+  MetaWaylandSurface *surface;
   ClutterActor *actor;
 
   actor = clutter_stage_get_device_actor (stage,
@@ -614,11 +652,11 @@ repick_for_event (MetaWaylandTabletTool *tool,
                                           clutter_event_get_event_sequence (for_event));
 
   if (META_IS_SURFACE_ACTOR_WAYLAND (actor))
-    tool->current = meta_surface_actor_wayland_get_surface (META_SURFACE_ACTOR_WAYLAND (actor));
+    surface = meta_surface_actor_wayland_get_surface (META_SURFACE_ACTOR_WAYLAND (actor));
   else
-    tool->current = NULL;
+    surface = NULL;
 
-  sync_focus_surface (tool, for_event);
+  meta_wayland_tablet_tool_set_current_surface (tool, surface);
   meta_wayland_tablet_tool_update_cursor_surface (tool);
 }
 
-- 
2.45.0


From 243890a6886262717447afe0c6d1c329e86643c9 Mon Sep 17 00:00:00 2001
From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 25 Apr 2024 23:56:27 +0200
Subject: [PATCH 04/44] wayland: Do not forget immediately of key press serials
 on key release

Prior to commit 5dfed8a431, the MetaWaylandKeyboard would always remember
the last key press serial, and consider it valid after the key was released,
as long as no other key presses/releases happened in between.

That commit improved things so that MetaWaylandKeyboard can track multiple
keys being pressed simultaneously, but also changed so that the serial for
a key press is immediately forgotten after the key press event was received.
This may break in situations like testing or keyboard macros where key
press and release is handled in a quick sucession, so the client reaction
to the key press (e.g. popping up a menu) might arrive too late.

Add a sort of spiritual successor to this handling, and make keyboard
press serials corresponding to the last key up forgotten at the next
key press/release received.

Fixes: 5dfed8a431 ("wayland: Preserve serial for all pressed keys")
Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/3458
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3721>
---
 src/wayland/meta-wayland-keyboard.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/wayland/meta-wayland-keyboard.c b/src/wayland/meta-wayland-keyboard.c
index 80c772aec..3c741a0ae 100644
--- a/src/wayland/meta-wayland-keyboard.c
+++ b/src/wayland/meta-wayland-keyboard.c
@@ -77,6 +77,7 @@ struct _MetaWaylandKeyboard
   struct wl_array pressed_keys;
   GHashTable *key_down_serials;
   uint32_t last_key_up_serial;
+  uint32_t last_key_up;
 
   MetaWaylandXkbInfo xkb_info;
   enum xkb_state_component mods_changed;
@@ -279,6 +280,13 @@ meta_wayland_keyboard_broadcast_key (MetaWaylandKeyboard *keyboard,
 
       serial = meta_wayland_input_device_next_serial (input_device);
 
+      if (keyboard->last_key_up)
+        {
+          g_hash_table_remove (keyboard->key_down_serials,
+                               GUINT_TO_POINTER (keyboard->last_key_up));
+          keyboard->last_key_up = 0;
+        }
+
       if (state)
         {
           g_hash_table_insert (keyboard->key_down_serials,
@@ -288,9 +296,8 @@ meta_wayland_keyboard_broadcast_key (MetaWaylandKeyboard *keyboard,
         }
       else
         {
-          g_hash_table_remove (keyboard->key_down_serials,
-                               GUINT_TO_POINTER (key));
           keyboard->last_key_up_serial = serial;
+          keyboard->last_key_up = key;
         }
 
       wl_resource_for_each (resource, &keyboard->focus_resource_list)
-- 
2.45.0


From d9207ee496a1d625b7e490ad2e17e6a146705f43 Mon Sep 17 00:00:00 2001
From: Hugo Carvalho <hugokarvalho@hotmail.com>
Date: Sun, 28 Apr 2024 20:15:31 +0000
Subject: [PATCH 05/44] Update Portuguese translation

(cherry picked from commit d9fe1988e7808c162873b820e4af5c1a291d9fe0)
---
 po/pt.po | 142 +++++++++++++++++++++++++++++--------------------------
 1 file changed, 75 insertions(+), 67 deletions(-)

diff --git a/po/pt.po b/po/pt.po
index 88da88047..c9968e95d 100644
--- a/po/pt.po
+++ b/po/pt.po
@@ -5,14 +5,14 @@
 # Pedro Albuquerque <palbuquerque73@openmailbox.com>, 2015.
 # Tiago Santos <tiagofsantos81@sapo.pt>, 2016.
 # Juliano de Souza Camargo <julianosc@protonmail.com>, 2020.
-# Hugo Carvalho <hugokarvalho@hotmail.com>, 2020, 2021, 2022, 2023.
+# Hugo Carvalho <hugokarvalho@hotmail.com>, 2020, 2021, 2022, 2023, 2024.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: 3.10\n"
-"Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2023-07-16 01:41+0000\n"
-"PO-Revision-Date: 2023-08-04 17:11+0100\n"
+"Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues/\n"
+"POT-Creation-Date: 2024-04-21 15:14+0000\n"
+"PO-Revision-Date: 2024-04-28 21:14+0100\n"
 "Last-Translator: Hugo Carvalho <hugokarvalho@hotmail.com>\n"
 "Language-Team: https://l10n.gnome.org/teams/pt/\n"
 "Language: pt\n"
@@ -20,7 +20,7 @@ msgstr ""
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
-"X-Generator: Poedit 3.3.2\n"
+"X-Generator: Poedit 3.4.2\n"
 "X-DamnedLies-Scope: partial\n"
 
 #: data/50-mutter-navigation.xml:6
@@ -251,11 +251,11 @@ msgstr "Maximizar janela verticalmente"
 msgid "Maximize window horizontally"
 msgstr "Maximizar janela horizontalmente"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:164
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:167
 msgid "View split on left"
 msgstr "Ver a divisão à esquerda"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:169
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:172
 msgid "View split on right"
 msgstr "Ver a divisão à direita"
 
@@ -396,39 +396,43 @@ msgid ""
 "space, while scaling monitor framebuffers instead of window content, to "
 "manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
 "mutter always allocate scanout buffers with explicit modifiers, if supported "
-"by the driver. Requires a restart. • “rt-scheduler” — makes mutter request a "
-"low priority real-time scheduling. Requires a restart. • “autoclose-"
-"xwayland” — automatically terminates Xwayland if all relevant X11 clients "
-"are gone. Requires a restart."
+"by the driver. Requires a restart. • “autoclose-xwayland” — automatically "
+"terminates Xwayland if all relevant X11 clients are gone. Requires a "
+"restart. • “variable-refresh-rate” — makes mutter dynamically adjust the "
+"refresh rate of the monitor when applicable if supported by the monitor, GPU "
+"and DRM driver. Configurable in Settings. Requires a restart."
 msgstr ""
-"Para ativar as funcionalidades experimentais, adicione a respetiva palavra-"
-"chave à lista. Se deve reiniciar o compositor após ativá-la, depende de cada "
-"funcionalidade. Qualquer funcionalidade experimental não necessita de estar "
-"disponível ou configurável. Não espere que adicionar algo nas definições "
-"seja mantido por tempo indeterminado. Atualmente as palavras-chave são: • "
-"“scale-monitor-framebuffer” — torna o mutter padrão para a disposição de "
-"monitores lógicos num espaço de coordenadas de pixel lógico, enquanto "
-"dimensiona os framebuffers do monitor em vez do conteúdo da janela, para "
-"gerir monitores HiDPI. Não requer um reinício. • “kms-modifiers” — faz o "
-"mutter publicitar sempre modificadores buffer. se suportado pelo "
-"controlador. Requer um reinício. - \"rt-scheduler\" - torna o pedido do "
-"mutter uma programação em tempo real de baixa prioridade. Requer um "
-"reinício. • “autoclose-xwayland” — Termina automaticamente o Xwayland se "
-"todos os clientes X11 relevantes desapareceram. Requer um reinício."
-
-#: data/org.gnome.mutter.gschema.xml.in:141
+"Para ativar funcionalidades experimentais, adicione a palavra-chave "
+"caraterística à lista. O facto de a funcionalidade exigir o reinício do "
+"compositor depende da funcionalidade em causa. Não é necessário que qualquer "
+"recurso experimental ainda esteja disponível ou configurável. Não espere que "
+"adicionar algo nesta configuração seja à prova de futuro. Palavras-chave "
+"atualmente possíveis: - “scale-monitor-framebuffer” - torna o mutter padrão "
+"para a disposição de monitores lógicos em um espaço lógico de coordenadas de "
+"pixel, enquanto escala os framebuffers do monitor em vez do conteúdo da "
+"janela, para gerenciar monitores HiDPI. Não requer uma reinicialização. - "
+"“kms-modifiers” - faz com que o mutter sempre aloque buffers de \"scanout\" "
+"com modificadores explícitos, se suportados pelo controlador. Requer uma "
+"reinicialização. - “autoclose-xwayland” - termina automaticamente o Xwayland "
+"se todos os clientes X11 relevantes tiverem desaparecido. Requer um "
+"reinício. - “variable-refresh-rate” - faz com que o mutter ajuste "
+"dinamicamente a taxa de atualização do monitor quando aplicável, se "
+"suportado pelo monitor, GPU e driver DRM. Configurável em Definições. Requer "
+"uma reinicialização."
+
+#: data/org.gnome.mutter.gschema.xml.in:144
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificador para localizar o cursor"
 
-#: data/org.gnome.mutter.gschema.xml.in:142
+#: data/org.gnome.mutter.gschema.xml.in:145
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Esta chave iniciará a ação “localizar cursor”."
 
-#: data/org.gnome.mutter.gschema.xml.in:149
+#: data/org.gnome.mutter.gschema.xml.in:152
 msgid "Timeout for check-alive ping"
 msgstr "Expirou o teste de atividade"
 
-#: data/org.gnome.mutter.gschema.xml.in:150
+#: data/org.gnome.mutter.gschema.xml.in:153
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -437,15 +441,15 @@ msgstr ""
 "atividade de maneira que não seja detetado como inativo. Usar 0 desativará o "
 "teste de atividade completamente."
 
-#: data/org.gnome.mutter.gschema.xml.in:174
+#: data/org.gnome.mutter.gschema.xml.in:177
 msgid "Switch monitor configurations"
 msgstr "Alternar configurações de ecrã"
 
-#: data/org.gnome.mutter.gschema.xml.in:179
+#: data/org.gnome.mutter.gschema.xml.in:182
 msgid "Rotates the built-in monitor configuration"
 msgstr "Alternar as configurações nativas do ecrã"
 
-#: data/org.gnome.mutter.gschema.xml.in:184
+#: data/org.gnome.mutter.gschema.xml.in:187
 msgid "Cancel any active input capture session"
 msgstr "Cancelar qualquer sessão de captura de entrada ativa"
 
@@ -603,26 +607,26 @@ msgstr ""
 "configuração. O Xwayland precisa de ser reiniciado para que esta "
 "configuração tenha efeito."
 
-#: src/backends/meta-monitor.c:253
+#: src/backends/meta-monitor.c:251
 msgid "Built-in display"
 msgstr "Ecrã embutido"
 
-#: src/backends/meta-monitor.c:280
+#: src/backends/meta-monitor.c:278
 msgid "Unknown"
 msgstr "Desconhecido"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:280
 msgid "Unknown Display"
 msgstr "Ecrã desconhecido"
 
-#: src/backends/meta-monitor.c:290
+#: src/backends/meta-monitor.c:288
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:298
+#: src/backends/meta-monitor.c:296
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -634,78 +638,82 @@ msgstr "%s %s"
 msgid "Bell event"
 msgstr "Evento de campainha"
 
-#: src/core/display.c:718
+#: src/core/display.c:734
 msgid "Privacy Screen Enabled"
 msgstr "Ecrã de privacidade ativado"
 
-#: src/core/display.c:719
+#: src/core/display.c:735
 msgid "Privacy Screen Disabled"
 msgstr "Ecrã de privacidade desativado"
 
-#: src/core/meta-context-main.c:581
+#: src/core/meta-context-main.c:601
 msgid "Replace the running window manager"
 msgstr "Substituir o gestor de janelas em execução"
 
-#: src/core/meta-context-main.c:587
+#: src/core/meta-context-main.c:607
 msgid "X Display to use"
 msgstr "Ecrã X a utilizar"
 
-#: src/core/meta-context-main.c:593
+#: src/core/meta-context-main.c:613
 msgid "Disable connection to session manager"
 msgstr "Desativar a ligação ao gestor de sessão"
 
-#: src/core/meta-context-main.c:599
+#: src/core/meta-context-main.c:619
 msgid "Specify session management ID"
 msgstr "Especificar a ID de gestão de sessão"
 
-#: src/core/meta-context-main.c:605
+#: src/core/meta-context-main.c:625
 msgid "Initialize session from savefile"
 msgstr "Inicializar a sessão a partir de um ficheiro de gravação de sessão"
 
-#: src/core/meta-context-main.c:611
+#: src/core/meta-context-main.c:631
 msgid "Make X calls synchronous"
 msgstr "Fazer as chamadas X sincronamente"
 
-#: src/core/meta-context-main.c:619
+#: src/core/meta-context-main.c:639
 msgid "Run as a wayland compositor"
 msgstr "Executar como compositor wayland"
 
-#: src/core/meta-context-main.c:625
+#: src/core/meta-context-main.c:645
 msgid "Run as a nested compositor"
 msgstr "Executar como compositor aninhado"
 
-#: src/core/meta-context-main.c:631
+#: src/core/meta-context-main.c:651
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Executar o compositor wayland sem a utilização do Xwayland"
 
-#: src/core/meta-context-main.c:637
+#: src/core/meta-context-main.c:657
 msgid "Specify Wayland display name to use"
 msgstr "Especificar o nome do visor Wayland a utilizar"
 
-#: src/core/meta-context-main.c:645
+#: src/core/meta-context-main.c:665
 msgid "Run as a full display server, rather than nested"
 msgstr "Executar como servidor de ecrã inteiro, em vez de aninhado"
 
-#: src/core/meta-context-main.c:650
+#: src/core/meta-context-main.c:670
 msgid "Run as a headless display server"
 msgstr "Executar como um servidor sem monitor"
 
-#: src/core/meta-context-main.c:655
+#: src/core/meta-context-main.c:675
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Adicionar monitor virtual persistente (WxH ou WxH@R)"
 
-#: src/core/meta-context-main.c:667
+#: src/core/meta-context-main.c:687
 msgid "Run with X11 backend"
 msgstr "Executar com a infira-estrutura X11"
 
-#: src/core/meta-context-main.c:673
+#: src/core/meta-context-main.c:693
 msgid "Profile performance using trace instrumentation"
 msgstr "Desempenho do perfil utilizando instrumentação de rastreio"
 
+#: src/core/meta-context-main.c:699
+msgid "Enable debug control D-Bus interface"
+msgstr "Ativar o controlo de depuração da interface D-Bus"
+
 #. TRANSLATORS: This string refers to a button that switches between
 #. * different modes.
 #.
-#: src/core/meta-pad-action-mapper.c:861
+#: src/core/meta-pad-action-mapper.c:826
 #, c-format
 msgid "Mode Switch (Group %d)"
 msgstr "Alteração de modo (Grupo %d)"
@@ -713,16 +721,16 @@ msgstr "Alteração de modo (Grupo %d)"
 #. TRANSLATORS: This string refers to an action, cycles drawing tablets'
 #. * mapping through the available outputs.
 #.
-#: src/core/meta-pad-action-mapper.c:884
+#: src/core/meta-pad-action-mapper.c:848
 msgid "Switch monitor"
 msgstr "Alternar monitor"
 
-#: src/core/meta-pad-action-mapper.c:886
+#: src/core/meta-pad-action-mapper.c:850
 msgid "Show on-screen help"
 msgstr "Mostrar ajuda no ecrã"
 
 #. Translators: this string will appear in Sysprof
-#: src/core/meta-profiler.c:111 src/core/meta-profiler.c:301
+#: src/core/meta-profiler.c:109 src/core/meta-profiler.c:299
 msgid "Compositor"
 msgstr "Compositor"
 
@@ -734,7 +742,7 @@ msgstr "Imprimir a versão"
 msgid "Mutter plugin to use"
 msgstr "Extensão Mutter a utilizar"
 
-#: src/core/prefs.c:1843
+#: src/core/prefs.c:1842
 #, c-format
 msgid "Workspace %d"
 msgstr "Área de trabalho %d"
@@ -743,16 +751,16 @@ msgstr "Área de trabalho %d"
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "O Mutter foi compilado sem suporte para modo verbose"
 
-#: src/core/workspace.c:541
+#: src/core/workspace.c:510
 msgid "Workspace switched"
 msgstr "Área de trabalho alterada"
 
-#: src/wayland/meta-wayland-tablet-pad.c:530
+#: src/wayland/meta-wayland-tablet-pad.c:532
 #, c-format
 msgid "Mode Switch: Mode %d"
 msgstr "Alteração de Modo: Modo %d"
 
-#: src/x11/meta-x11-display.c:708
+#: src/x11/meta-x11-display.c:723
 #, c-format
 msgid ""
 "Display “%s” already has a window manager; try using the --replace option to "
@@ -761,19 +769,19 @@ msgstr ""
 "O ecrã “%s” já tem um gestor de janelas; tente utilizar a opção --replace "
 "para substituir o gestor de janelas atual."
 
-#: src/x11/meta-x11-display.c:1073
+#: src/x11/meta-x11-display.c:1088
 #, c-format
 msgid "Failed to open X Window System display “%s”"
 msgstr "Falha ao abrir ecrã “%s” do sistema Janelas X"
 
-#: src/x11/meta-x11-display.c:1219
+#: src/x11/meta-x11-display.c:1268
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "Ecrã %d no monitor “%s” é inválido"
 
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/x11/meta-x11-display.c:2550
+#: src/x11/meta-x11-display.c:2547
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -785,7 +793,7 @@ msgstr ""
 msgid "Format %s not supported"
 msgstr "O formato “%s” não é suportado"
 
-#: src/x11/window-props.c:548
+#: src/x11/window-props.c:528
 #, c-format
 msgid "%s (on %s)"
 msgstr "%s (em %s)"
-- 
2.45.0


From 0f11ef6c1244979d2c3a909206684a731299732f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Le=C3=B4nidas=20Ara=C3=BAjo?= <leorusvellt@hotmail.com>
Date: Mon, 29 Apr 2024 18:00:41 +0000
Subject: [PATCH 06/44] Update Brazilian Portuguese translation

---
 po/pt_BR.po | 184 +++++++++++++++++++++++++++-------------------------
 1 file changed, 95 insertions(+), 89 deletions(-)

diff --git a/po/pt_BR.po b/po/pt_BR.po
index 7aa47475d..7d8876e2f 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -1,39 +1,39 @@
-# Brazilian Portuguese translation of mutter.
-# Copyright (C) 2022 Free Software Foundation, Inc.
-# This file is distributed under the same license as the mutter package.
-# Sun G11n <gnome_int_l10n@ireland.sun.com>, 2002.
-# Evandro Fernandes Giovanini <evandrofg@ig.com.br>, 2002, 2003, 2006.
-# Gustavo Noronha Silva <kov@debian.org>, 2004.
-# Alexandre Folle de Menezes <afmenez@terra.com.br>, 2005.
-# Leonardo Ferreira Fontenelle <leonardof@gnome.org>, 2007, 2008.
-# Raul Pereira <contato@raulpereira.com>, 2007.
-# Og Maciel <ogmaciel@gnome.org>, 2007-2008.
-# Rodrigo Flores <rodrigomarquesflores@gmail.com>, 2007.
-# Djavan Fagundes <djavanf@gnome.org>, 2008, 2009, 2011.
-# Vladimir Melo <vmelo@gnome.org>, 2009.
-# Antonio Fernandes C. Neto <fernandes@pelivre.org>, 2010.
-# Rodrigo Padula de Oliveira <contato@rodrigopadula.com>, 2011.
-# Artur de Aquino Morais <artur.morais93@outlook.com>, 2016.
-# Enrico Nicoletto <liverig@gmail.com>, 2012-2016, 2021.
-# Matheus Barbosa <mdpb.matheus@gmail.com>, 2022.
-# Leônidas Araújo <leorusvellt@hotmail.com>, 2022-2023.
-# 
+# Brazilian Portuguese translation of mutter.
+# Copyright (C) 2022 Free Software Foundation, Inc.
+# This file is distributed under the same license as the mutter package.
+# Sun G11n <gnome_int_l10n@ireland.sun.com>, 2002.
+# Evandro Fernandes Giovanini <evandrofg@ig.com.br>, 2002, 2003, 2006.
+# Gustavo Noronha Silva <kov@debian.org>, 2004.
+# Alexandre Folle de Menezes <afmenez@terra.com.br>, 2005.
+# Leonardo Ferreira Fontenelle <leonardof@gnome.org>, 2007, 2008.
+# Raul Pereira <contato@raulpereira.com>, 2007.
+# Og Maciel <ogmaciel@gnome.org>, 2007-2008.
+# Rodrigo Flores <rodrigomarquesflores@gmail.com>, 2007.
+# Djavan Fagundes <djavanf@gnome.org>, 2008, 2009, 2011.
+# Vladimir Melo <vmelo@gnome.org>, 2009.
+# Antonio Fernandes C. Neto <fernandes@pelivre.org>, 2010.
+# Rodrigo Padula de Oliveira <contato@rodrigopadula.com>, 2011.
+# Artur de Aquino Morais <artur.morais93@outlook.com>, 2016.
+# Enrico Nicoletto <liverig@gmail.com>, 2012-2016, 2021.
+# Matheus Barbosa <mdpb.matheus@gmail.com>, 2022.
+# Leônidas Araújo <leorusvellt@hotmail.com>, 2022-2023.
+#
 # Rafael Fontenelle <rafaelff@gnome.org>, 2013-2023.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: mutter\n"
-"Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues\n"
-"POT-Creation-Date: 2023-08-23 16:49+0000\n"
-"PO-Revision-Date: 2023-09-25 13:20-0300\n"
-"Last-Translator: Rafael Fontenelle <rafaelff@gnome.org>\n"
+"Report-Msgid-Bugs-To: https://gitlab.gnome.org/GNOME/mutter/issues/\n"
+"POT-Creation-Date: 2024-03-02 12:22+0000\n"
+"PO-Revision-Date: 2024-04-04 18:40-0300\n"
+"Last-Translator: Leônidas Araújo <leorusvellt@hotmail.com>\n"
 "Language-Team: Brazilian Portuguese <https://br.gnome.org/traducao>\n"
 "Language: pt_BR\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"Plural-Forms: nplurals=2; plural=(n > 1)\n"
-"X-Generator: Gtranslator 45.alpha0\n"
+"Plural-Forms: nplurals=2; plural=(n > 1);\n"
+"X-Generator: Poedit 3.4.2\n"
 "X-Project-Style: gnome\n"
 "X-DL-Team: pt_BR\n"
 "X-DL-Module: mutter\n"
@@ -81,22 +81,22 @@ msgstr "Mover a janela para um espaço de trabalho acima"
 msgid "Move window one workspace down"
 msgstr "Mover a janela para um espaço de trabalho abaixo"
 
-# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
+# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
 #: data/50-mutter-navigation.xml:38
 msgid "Move window one monitor to the left"
 msgstr "Mover a janela para o monitor da esquerda"
 
-# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
+# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
 #: data/50-mutter-navigation.xml:41
 msgid "Move window one monitor to the right"
 msgstr "Mover a janela para o monitor da direita"
 
-# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
+# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
 #: data/50-mutter-navigation.xml:44
 msgid "Move window one monitor up"
 msgstr "Mover a janela para o monitor acima"
 
-# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
+# Em conformidade com a tradução do gsettings-desktop-schemas --Enrico
 #: data/50-mutter-navigation.xml:47
 msgid "Move window one monitor down"
 msgstr "Mover a janela para o monitor abaixo"
@@ -273,11 +273,11 @@ msgstr "Maximizar a janela verticalmente"
 msgid "Maximize window horizontally"
 msgstr "Maximizar a janela horizontalmente"
 
-#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:164
+#: data/50-mutter-windows.xml:41 data/org.gnome.mutter.gschema.xml.in:167
 msgid "View split on left"
 msgstr "Visualizar a divisão à esquerda"
 
-#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:169
+#: data/50-mutter-windows.xml:45 data/org.gnome.mutter.gschema.xml.in:172
 msgid "View split on right"
 msgstr "Visualizar a divisão à direita"
 
@@ -420,40 +420,42 @@ msgid ""
 "space, while scaling monitor framebuffers instead of window content, to "
 "manage HiDPI monitors. Does not require a restart. • “kms-modifiers” — makes "
 "mutter always allocate scanout buffers with explicit modifiers, if supported "
-"by the driver. Requires a restart. • “rt-scheduler” — makes mutter request a "
-"low priority real-time scheduling. Requires a restart. • “autoclose-"
-"xwayland” — automatically terminates Xwayland if all relevant X11 clients "
-"are gone. Requires a restart."
+"by the driver. Requires a restart. • “autoclose-xwayland” — automatically "
+"terminates Xwayland if all relevant X11 clients are gone. Requires a "
+"restart. • “variable-refresh-rate” — makes mutter dynamically adjust the "
+"refresh rate of the monitor when applicable if supported by the monitor, GPU "
+"and DRM driver. Configurable in Settings. Requires a restart."
 msgstr ""
-"Para ativar recursos experimentais, adicione a palavra-chave do recurso à "
-"lista. Se o recurso requer a reinicialização do compositor depende do "
-"recurso fornecido. Nenhum recurso experimental precisa estar disponível ou "
-"configurável. Não espere que adicionar nada nessa configuração seja à prova "
-"de futuro. Palavras-chave atualmente possíveis: • “scale-monitor-"
+"Para habilitar recursos experimentais, adicione a palavra-chave do recurso à "
+"lista. Dependendo do recurso fornecido, será necessário reiniciar o "
+"compositor. Qualquer recurso experimental não precisa ainda estar disponível "
+"ou configurável. Não espere que adicionar nada nesta configuração seja uma "
+"prova futura. Palavras-chave atualmente possíveis: • “scale-monitor-"
 "framebuffer” — torna o mutter padrão para o layout de monitores lógicos em "
-"um espaço de coordenadas de pixel lógico, enquanto dimensiona os "
+"um espaço lógico de coordenadas de pixel, enquanto dimensiona os "
 "framebuffers do monitor em vez do conteúdo da janela, para gerenciar "
-"monitores HiDPI. Não requer uma reinicialização. • “kms-modifiers” — faz com "
-"que o mutter sempre aloque buffers de varredura com modificadores "
-"explícitos, se suportado pelo driver. Requer uma reinicialização. • “rt-"
-"scheduler” — torna a solicitação de mutter um agendamento em tempo real de "
-"baixa prioridade. Requer uma reinicialização. • “autoclose-xwayland” — "
+"monitores HiDPI. Não requer reinicialização. • “kms-modifiers” — faz com que "
+"o mutter sempre aloque buffers de scanout com modificadores explícitos, se "
+"suportado pelo driver. Requer uma reinicialização. • “autoclose-xwayland” – "
 "encerra automaticamente o Xwayland se todos os clientes X11 relevantes "
-"desaparecerem. Requer uma reinicialização."
+"tiverem desaparecido. Requer uma reinicialização. • “variable-refresh-rate” "
+"— faz com que o mutter ajuste dinamicamente a taxa de atualização do monitor "
+"quando aplicável, se suportado pelo monitor, GPU e driver DRM. Configurável "
+"em Configurações. Requer uma reinicialização."
 
-#: data/org.gnome.mutter.gschema.xml.in:141
+#: data/org.gnome.mutter.gschema.xml.in:144
 msgid "Modifier to use to locate the pointer"
 msgstr "Modificador para usar ao localizar o ponteiro"
 
-#: data/org.gnome.mutter.gschema.xml.in:142
+#: data/org.gnome.mutter.gschema.xml.in:145
 msgid "This key will initiate the “locate pointer” action."
 msgstr "Essa chave vai iniciar a ação de “localizar ponteiro”."
 
-#: data/org.gnome.mutter.gschema.xml.in:149
+#: data/org.gnome.mutter.gschema.xml.in:152
 msgid "Timeout for check-alive ping"
 msgstr "Tempo limite para o ping de verificação ativa"
 
-#: data/org.gnome.mutter.gschema.xml.in:150
+#: data/org.gnome.mutter.gschema.xml.in:153
 msgid ""
 "Number of milliseconds a client has to respond to a ping request in order to "
 "not be detected as frozen. Using 0 will disable the alive check completely."
@@ -462,15 +464,15 @@ msgstr ""
 "uma solicitação de ping para não ser detectado como congelado. Usar 0 "
 "desativará completamente a verificação ativa."
 
-#: data/org.gnome.mutter.gschema.xml.in:174
+#: data/org.gnome.mutter.gschema.xml.in:177
 msgid "Switch monitor configurations"
 msgstr "Trocar configurações de monitor"
 
-#: data/org.gnome.mutter.gschema.xml.in:179
+#: data/org.gnome.mutter.gschema.xml.in:182
 msgid "Rotates the built-in monitor configuration"
 msgstr "Gira a configuração de monitor embutido"
 
-#: data/org.gnome.mutter.gschema.xml.in:184
+#: data/org.gnome.mutter.gschema.xml.in:187
 msgid "Cancel any active input capture session"
 msgstr "Cancelar qualquer sessão ativa de captura de entrada"
 
@@ -624,26 +626,26 @@ msgstr ""
 "byteswappedclients para controlar essa configuração. O Xwayland precisa ser "
 "reiniciado para que essa configuração entre em vigor."
 
-#: src/backends/meta-monitor.c:253
+#: src/backends/meta-monitor.c:251
 msgid "Built-in display"
 msgstr "Tela embutida"
 
-#: src/backends/meta-monitor.c:280
+#: src/backends/meta-monitor.c:278
 msgid "Unknown"
 msgstr "Desconhecido"
 
-#: src/backends/meta-monitor.c:282
+#: src/backends/meta-monitor.c:280
 msgid "Unknown Display"
 msgstr "Monitor desconhecido"
 
-#: src/backends/meta-monitor.c:290
+#: src/backends/meta-monitor.c:288
 #, c-format
 msgctxt ""
 "This is a monitor vendor name, followed by a size in inches, like 'Dell 15\"'"
 msgid "%s %s"
 msgstr "%s %s"
 
-#: src/backends/meta-monitor.c:298
+#: src/backends/meta-monitor.c:296
 #, c-format
 msgctxt ""
 "This is a monitor vendor name followed by product/model name where size in "
@@ -655,78 +657,82 @@ msgstr "%s %s"
 msgid "Bell event"
 msgstr "Evento de som"
 
-#: src/core/display.c:723
+#: src/core/display.c:734
 msgid "Privacy Screen Enabled"
 msgstr "Tela de privacidade habilitada"
 
-#: src/core/display.c:724
+#: src/core/display.c:735
 msgid "Privacy Screen Disabled"
 msgstr "Tela de privacidade desabilitada"
 
-#: src/core/meta-context-main.c:581
+#: src/core/meta-context-main.c:601
 msgid "Replace the running window manager"
 msgstr "Substitui o gerenciador de janelas em execução"
 
-#: src/core/meta-context-main.c:587
+#: src/core/meta-context-main.c:607
 msgid "X Display to use"
 msgstr "Tela X para usar"
 
-#: src/core/meta-context-main.c:593
+#: src/core/meta-context-main.c:613
 msgid "Disable connection to session manager"
 msgstr "Desabilita a conexão com o gerenciador de sessões"
 
-#: src/core/meta-context-main.c:599
+#: src/core/meta-context-main.c:619
 msgid "Specify session management ID"
 msgstr "Especifica o ID do gerenciador de sessões"
 
-#: src/core/meta-context-main.c:605
+#: src/core/meta-context-main.c:625
 msgid "Initialize session from savefile"
 msgstr "Inicializa a sessão a partir do arquivo salvo"
 
-#: src/core/meta-context-main.c:611
+#: src/core/meta-context-main.c:631
 msgid "Make X calls synchronous"
 msgstr "Faz X chamadas síncronas"
 
-#: src/core/meta-context-main.c:619
+#: src/core/meta-context-main.c:639
 msgid "Run as a wayland compositor"
 msgstr "Executa como um compositor wayland"
 
-#: src/core/meta-context-main.c:625
+#: src/core/meta-context-main.c:645
 msgid "Run as a nested compositor"
 msgstr "Executa como um compositor aninhado"
 
-#: src/core/meta-context-main.c:631
+#: src/core/meta-context-main.c:651
 msgid "Run wayland compositor without starting Xwayland"
 msgstr "Executa o compositor wayland sem iniciar o Xwayland"
 
-#: src/core/meta-context-main.c:637
+#: src/core/meta-context-main.c:657
 msgid "Specify Wayland display name to use"
 msgstr "Especifica o nome da tela Wayland para usar"
 
-#: src/core/meta-context-main.c:645
+#: src/core/meta-context-main.c:665
 msgid "Run as a full display server, rather than nested"
 msgstr "Executa como um servidor de tela cheia, ao invés de aninhado"
 
-#: src/core/meta-context-main.c:650
+#: src/core/meta-context-main.c:670
 msgid "Run as a headless display server"
 msgstr "Executa como um servidor de tela sem periféricos"
 
-#: src/core/meta-context-main.c:655
+#: src/core/meta-context-main.c:675
 msgid "Add persistent virtual monitor (WxH or WxH@R)"
 msgstr "Adicionar monitor virtual persistente (WxH ou WxH@R)"
 
-#: src/core/meta-context-main.c:667
+#: src/core/meta-context-main.c:687
 msgid "Run with X11 backend"
 msgstr "Executa com backend X11"
 
-#: src/core/meta-context-main.c:673
+#: src/core/meta-context-main.c:693
 msgid "Profile performance using trace instrumentation"
 msgstr "Perfila o desempenho usando instrumentação de rastreamento"
 
+#: src/core/meta-context-main.c:699
+msgid "Enable debug control D-Bus interface"
+msgstr "Habilitar interface D-Bus do controle de depuração"
+
 #. TRANSLATORS: This string refers to a button that switches between
 #. * different modes.
 #.
-#: src/core/meta-pad-action-mapper.c:807
+#: src/core/meta-pad-action-mapper.c:826
 #, c-format
 msgid "Mode Switch (Group %d)"
 msgstr "Alternador de modo (Grupo %d)"
@@ -734,16 +740,16 @@ msgstr "Alternador de modo (Grupo %d)"
 #. TRANSLATORS: This string refers to an action, cycles drawing tablets'
 #. * mapping through the available outputs.
 #.
-#: src/core/meta-pad-action-mapper.c:829
+#: src/core/meta-pad-action-mapper.c:848
 msgid "Switch monitor"
 msgstr "Trocar monitor"
 
-#: src/core/meta-pad-action-mapper.c:831
+#: src/core/meta-pad-action-mapper.c:850
 msgid "Show on-screen help"
 msgstr "Mostrar ajuda na tela"
 
 #. Translators: this string will appear in Sysprof
-#: src/core/meta-profiler.c:111 src/core/meta-profiler.c:301
+#: src/core/meta-profiler.c:109 src/core/meta-profiler.c:299
 msgid "Compositor"
 msgstr "Compositor"
 
@@ -755,7 +761,7 @@ msgstr "Versão impressa"
 msgid "Mutter plugin to use"
 msgstr "Plug-in do Mutter para usar"
 
-#: src/core/prefs.c:1843
+#: src/core/prefs.c:1842
 #, c-format
 msgid "Workspace %d"
 msgstr "Espaço de trabalho %d"
@@ -764,16 +770,16 @@ msgstr "Espaço de trabalho %d"
 msgid "Mutter was compiled without support for verbose mode"
 msgstr "O Mutter foi compilado sem suporte para modo detalhado"
 
-#: src/core/workspace.c:535
+#: src/core/workspace.c:510
 msgid "Workspace switched"
 msgstr "Espaço de trabalho alterado"
 
-#: src/wayland/meta-wayland-tablet-pad.c:534
+#: src/wayland/meta-wayland-tablet-pad.c:532
 #, c-format
 msgid "Mode Switch: Mode %d"
 msgstr "Alternador de modo: Modo %d"
 
-#: src/x11/meta-x11-display.c:708
+#: src/x11/meta-x11-display.c:723
 #, c-format
 msgid ""
 "Display “%s” already has a window manager; try using the --replace option to "
@@ -782,19 +788,19 @@ msgstr ""
 "A exibição “%s” já possui um gerenciador de janelas; tente usar a opção --"
 "replace para substituir o gerenciador de janelas atual."
 
-#: src/x11/meta-x11-display.c:1073
+#: src/x11/meta-x11-display.c:1088
 #, c-format
 msgid "Failed to open X Window System display “%s”"
 msgstr "Falha ao abrir a exibição “%s” do sistema de janelas X"
 
-#: src/x11/meta-x11-display.c:1219
+#: src/x11/meta-x11-display.c:1268
 #, c-format
 msgid "Screen %d on display “%s” is invalid"
 msgstr "A tela %d na exibição “%s” é inválida"
 
 #. This probably means that a non-WM compositor like xcompmgr is running;
 #. * we have no way to get it to exit
-#: src/x11/meta-x11-display.c:2540
+#: src/x11/meta-x11-display.c:2538
 #, c-format
 msgid ""
 "Another compositing manager is already running on screen %i on display “%s”."
@@ -807,7 +813,7 @@ msgstr ""
 msgid "Format %s not supported"
 msgstr "Sem suporte ao formato %s"
 
-#: src/x11/window-props.c:548
+#: src/x11/window-props.c:528
 #, c-format
 msgid "%s (on %s)"
 msgstr "%s (em %s)"
-- 
2.45.0


From 3155cf514c69a5861c8f1dbf4cb9878c0827af94 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Florian=20M=C3=BCllner?= <fmuellner@gnome.org>
Date: Mon, 29 Apr 2024 15:13:40 +0200
Subject: [PATCH 07/44] ci: Bump image

GLib 2.79.2 split out platform specific API into separate GIRs,
and gjs now warns when using affected API without the new import.

However our CI image still only includes the 2.79.1 development
release, so in order to allow gnome-shell to depend on a more
recent glib release, bump the image to pull in a newer version.

Related: https://gitlab.gnome.org/GNOME/gnome-shell/-/merge_requests/3288
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3723>
---
 .gitlab-ci.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 5020c9bed..485321eb2 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -85,7 +85,7 @@ variables:
     - .skip-git-clone
   variables:
     FDO_DISTRIBUTION_VERSION: 40
-    BASE_TAG: '2024-02-23.0'
+    BASE_TAG: '2024-04-29.0'
     MUTTER_USER: 'meta-user'
     FDO_DISTRIBUTION_PACKAGES:
       asciidoc
-- 
2.45.0


From b67f94ca7eefdc3ad2a486c4740d1c267255187a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 30 Apr 2024 15:35:14 +0200
Subject: [PATCH 08/44] wayland/subsurface: Hold sibling surface reference in
 placement ops

It was possible for the sibling surface to be already destroyed in
meta_wayland_transaction_add_placement_surfaces, in which case
g_object_ref would return NULL for it, and
meta_wayland_transaction_commit would then crash dereferencing a NULL
surface pointer.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/3462
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3725>
---
 src/wayland/meta-wayland-subsurface.c | 12 ++++++++++--
 src/wayland/meta-wayland-subsurface.h |  2 ++
 src/wayland/meta-wayland-surface.c    |  3 ++-
 3 files changed, 14 insertions(+), 3 deletions(-)

diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index b88f3d7f4..fd9df170b 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -317,7 +317,6 @@ get_subsurface_placement_op (MetaWaylandSurface             *surface,
   GNode *sibling_node;
 
   op->placement = placement;
-  op->sibling = sibling;
   op->surface = surface;
 
   g_node_unlink (surface->committed_state.subsurface_branch_node);
@@ -325,6 +324,8 @@ get_subsurface_placement_op (MetaWaylandSurface             *surface,
   if (!sibling)
     return op;
 
+  op->sibling = g_object_ref (sibling);
+
   if (sibling == parent)
     sibling_node = parent->committed_state.subsurface_leaf_node;
   else
@@ -347,6 +348,13 @@ get_subsurface_placement_op (MetaWaylandSurface             *surface,
   return op;
 }
 
+void
+meta_wayland_subsurface_destroy_placement_op (MetaWaylandSubsurfacePlacementOp *op)
+{
+  g_clear_object (&op->sibling);
+  g_free (op);
+}
+
 static void
 subsurface_place (struct wl_client               *client,
                   struct wl_resource             *resource,
@@ -410,7 +418,7 @@ meta_wayland_subsurface_drop_placement_ops (MetaWaylandSurfaceState *state,
 
       if (op->surface == surface)
         {
-          g_free (link->data);
+          meta_wayland_subsurface_destroy_placement_op (op);
           *list = g_slist_delete_link (*list, link);
         }
       else
diff --git a/src/wayland/meta-wayland-subsurface.h b/src/wayland/meta-wayland-subsurface.h
index a4407b7d4..e185bf713 100644
--- a/src/wayland/meta-wayland-subsurface.h
+++ b/src/wayland/meta-wayland-subsurface.h
@@ -44,6 +44,8 @@ void meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
                                              int                    parent_y,
                                              MtkRectangle          *out_geometry);
 
+void meta_wayland_subsurface_destroy_placement_op (MetaWaylandSubsurfacePlacementOp *op);
+
 void meta_wayland_subsurface_drop_placement_ops (MetaWaylandSurfaceState *state,
                                                  MetaWaylandSurface      *surface);
 
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index 64d94080c..b433a5b1b 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -493,7 +493,8 @@ meta_wayland_surface_state_clear (MetaWaylandSurfaceState *state)
     wl_resource_destroy (cb->resource);
 
   if (state->subsurface_placement_ops)
-    g_slist_free_full (state->subsurface_placement_ops, g_free);
+    g_slist_free_full (state->subsurface_placement_ops,
+                       (GDestroyNotify) meta_wayland_subsurface_destroy_placement_op);
 
   meta_wayland_surface_state_discard_presentation_feedback (state);
 }
-- 
2.45.0


From dd32f3b3be16d84918df33413088ad9765bc9ba0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <mdaenzer@redhat.com>
Date: Tue, 30 Apr 2024 15:43:38 +0200
Subject: [PATCH 09/44] wayland/transaction: Check surface pointer validity in
 _ensure_entry

If a caller passes in NULL or a non-NULL value which doesn't point to
a valid MetaWaylandSurface object, this will hopefully point in the
direction of the cause.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3725>
---
 src/wayland/meta-wayland-transaction.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 694ce6dbe..17d702926 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -485,8 +485,12 @@ meta_wayland_transaction_ensure_entry (MetaWaylandTransaction *transaction,
   if (entry)
     return entry;
 
+  g_return_val_if_fail (surface, NULL);
+  surface = g_object_ref (surface);
+  g_return_val_if_fail (surface, NULL);
+
   entry = g_new0 (MetaWaylandTransactionEntry, 1);
-  g_hash_table_insert (transaction->entries, g_object_ref (surface), entry);
+  g_hash_table_insert (transaction->entries, surface, entry);
 
   return entry;
 }
-- 
2.45.0


From b620dbb1888eb506ad46ba621f410523f5fbf9b4 Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Tue, 2 Apr 2024 17:13:13 +0800
Subject: [PATCH 10/44] kms/impl-device: Add function
 meta_kms_impl_device_has_cursor_plane_for

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3676>
---
 src/backends/native/meta-kms-impl-device.c | 20 ++++++++++++++++++++
 src/backends/native/meta-kms-impl-device.h |  3 +++
 2 files changed, 23 insertions(+)

diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index b15eee14d..980487482 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -198,6 +198,26 @@ meta_kms_impl_device_peek_planes (MetaKmsImplDevice *impl_device)
   return priv->planes;
 }
 
+gboolean
+meta_kms_impl_device_has_cursor_plane_for (MetaKmsImplDevice *impl_device,
+                                           MetaKmsCrtc       *crtc)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  GList *l;
+
+  for (l = priv->planes; l; l = l->next)
+    {
+      MetaKmsPlane *plane = l->data;
+
+      if (meta_kms_plane_get_plane_type (plane) == META_KMS_PLANE_TYPE_CURSOR &&
+          meta_kms_plane_is_usable_with (plane, crtc))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 const MetaKmsDeviceCaps *
 meta_kms_impl_device_get_caps (MetaKmsImplDevice *impl_device)
 {
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index 271ccbfd1..d32e06630 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -119,6 +119,9 @@ GList * meta_kms_impl_device_peek_crtcs (MetaKmsImplDevice *impl_device);
 
 GList * meta_kms_impl_device_peek_planes (MetaKmsImplDevice *impl_device);
 
+gboolean meta_kms_impl_device_has_cursor_plane_for (MetaKmsImplDevice *impl_device,
+                                                    MetaKmsCrtc       *crtc);
+
 const MetaKmsDeviceCaps * meta_kms_impl_device_get_caps (MetaKmsImplDevice *impl_device);
 
 GList * meta_kms_impl_device_copy_fallback_modes (MetaKmsImplDevice *impl_device);
-- 
2.45.0


From 14e18de90d418e2bb33f5e0621162feb268e588f Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Thu, 28 Mar 2024 17:51:21 +0800
Subject: [PATCH 11/44] backends/native: Add fake cursor plane using
 impl_device's crtcs

Because `meta_kms_impl_device_simple_initable_init` is called in the
middle of `meta_kms_device_new`, the crtcs list for `MetaKmsDevice`
has not been populated yet. And thus the loop to detect missing
cursor planes and create fake ones never iterated. But the crtcs list
does already exist in `MetaKmsImplDevice` so iterate over that instead.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/3264
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3676>
---
 src/backends/native/meta-kms-impl-device-simple.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index 0e9dbaced..9c46bbe0e 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -1832,7 +1832,6 @@ meta_kms_impl_device_simple_initable_init (GInitable     *initable,
   MetaKmsImplDeviceSimple *impl_device_simple =
     META_KMS_IMPL_DEVICE_SIMPLE (initable);
   MetaKmsImplDevice *impl_device = META_KMS_IMPL_DEVICE (impl_device_simple);
-  MetaKmsDevice *device = meta_kms_impl_device_get_device (impl_device);
   GList *l;
 
   if (!initable_parent_iface->init (initable, cancellable, error))
@@ -1847,11 +1846,11 @@ meta_kms_impl_device_simple_initable_init (GInitable     *initable,
                            NULL,
                            (GDestroyNotify) cached_mode_set_free);
 
-  for (l = meta_kms_device_get_crtcs (device); l; l = l->next)
+  for (l = meta_kms_impl_device_peek_crtcs (impl_device); l; l = l->next)
     {
       MetaKmsCrtc *crtc = l->data;
 
-      if (meta_kms_device_has_cursor_plane_for (device, crtc))
+      if (meta_kms_impl_device_has_cursor_plane_for (impl_device, crtc))
         continue;
 
       meta_topic (META_DEBUG_KMS,
@@ -1859,9 +1858,9 @@ meta_kms_impl_device_simple_initable_init (GInitable     *initable,
                   meta_kms_crtc_get_id (crtc),
                   meta_kms_impl_device_get_path (impl_device));
 
-      meta_kms_device_add_fake_plane_in_impl (device,
-                                              META_KMS_PLANE_TYPE_CURSOR,
-                                              crtc);
+      meta_kms_impl_device_add_fake_plane (impl_device,
+                                           META_KMS_PLANE_TYPE_CURSOR,
+                                           crtc);
     }
 
   g_message ("Added device '%s' (%s) using non-atomic mode setting.",
-- 
2.45.0


From f3a52551f1bfc909d534df335a1c3009a6d15dfc Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Tue, 2 Apr 2024 16:44:52 +0800
Subject: [PATCH 12/44] backends/native: Remove unused
 meta_kms_device_add_fake_plane_in_impl

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3676>
---
 src/backends/native/meta-kms-device-private.h |  4 ----
 src/backends/native/meta-kms-device.c         | 16 ----------------
 2 files changed, 20 deletions(-)

diff --git a/src/backends/native/meta-kms-device-private.h b/src/backends/native/meta-kms-device-private.h
index 714700455..11c6d09b4 100644
--- a/src/backends/native/meta-kms-device-private.h
+++ b/src/backends/native/meta-kms-device-private.h
@@ -27,10 +27,6 @@ MetaKmsResourceChanges meta_kms_device_update_states_in_impl (MetaKmsDevice *dev
                                                               uint32_t       crtc_id,
                                                               uint32_t       connector_id);
 
-void meta_kms_device_add_fake_plane_in_impl (MetaKmsDevice    *device,
-                                             MetaKmsPlaneType  plane_type,
-                                             MetaKmsCrtc      *crtc);
-
 MetaKmsCrtc * meta_kms_device_find_crtc_in_impl (MetaKmsDevice *device,
                                                  uint32_t       crtc_id);
 
diff --git a/src/backends/native/meta-kms-device.c b/src/backends/native/meta-kms-device.c
index 83d9f8b6d..127a05de7 100644
--- a/src/backends/native/meta-kms-device.c
+++ b/src/backends/native/meta-kms-device.c
@@ -423,22 +423,6 @@ meta_kms_device_handle_flush (MetaKmsDevice *device,
   return needs_flush;
 }
 
-void
-meta_kms_device_add_fake_plane_in_impl (MetaKmsDevice    *device,
-                                        MetaKmsPlaneType  plane_type,
-                                        MetaKmsCrtc      *crtc)
-{
-  MetaKmsImplDevice *impl_device = device->impl_device;
-  MetaKmsPlane *plane;
-
-  meta_assert_in_kms_impl (device->kms);
-
-  plane = meta_kms_impl_device_add_fake_plane (impl_device,
-                                               plane_type,
-                                               crtc);
-  device->planes = g_list_append (device->planes, plane);
-}
-
 typedef struct _CreateImplDeviceData
 {
   MetaKmsDevice *device;
-- 
2.45.0


From 2a88a3eb963590ff0ceca78ce00f5f9deff959b2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marco=20Trevisan=20=28Trevi=C3=B1o=29?= <mail@3v1n0.net>
Date: Wed, 1 May 2024 02:52:59 +0200
Subject: [PATCH 13/44] x11/window: Do not try to compare a wayland active
 window with X11

If a window sends a configure stacking request, we were comparing the
active window with the event window even though they were different
client types (e.g. wayland and x11).

This was leading to a critical error, so let's handle this by ensuring
that the active window is of the same kind of the event window before
doing x11-specific checks. Behaving as different applications in case.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3727>
---
 src/x11/window-x11.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 210f4a133..536ccf447 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -2861,8 +2861,9 @@ meta_window_x11_configure_request (MetaWindow *window,
                       window->desc);
         }
       else if (active_window &&
-               !meta_window_x11_same_application (window, active_window) &&
-               !meta_window_same_client (window, active_window) &&
+               (active_window->client_type != window->client_type ||
+                (!meta_window_x11_same_application (window, active_window) &&
+                 !meta_window_same_client (window, active_window))) &&
                XSERVER_TIME_IS_BEFORE (window->net_wm_user_time,
                                        active_window->net_wm_user_time))
         {
-- 
2.45.0


From b422393bbcc063e7f2cde614ce36b770b15e8273 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marco=20Trevisan=20=28Trevi=C3=B1o=29?= <mail@3v1n0.net>
Date: Wed, 1 May 2024 03:14:45 +0200
Subject: [PATCH 14/44] x11/window: Add type-check guard to
 meta_window_x11_get_group()

Since this is still public API we want to ensure that we don't cast
it directly without having checked its type

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3727>
---
 src/x11/window-x11.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 536ccf447..b87c5072a 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -4536,6 +4536,8 @@ meta_window_x11_get_group (MetaWindow *window)
   MetaWindowX11 *window_x11;
   MetaWindowX11Private *priv;
 
+  g_return_val_if_fail (META_IS_WINDOW_X11 (window), NULL);
+
   if (window->unmanaging)
     return NULL;
 
-- 
2.45.0


From 31165c2d86ec2ee9cab80d1e189085afc3514d87 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marco=20Trevisan=20=28Trevi=C3=B1o=29?= <mail@3v1n0.net>
Date: Wed, 1 May 2024 03:15:51 +0200
Subject: [PATCH 15/44] x11/window: Add proper type guard to x11-specific
 public API calls

These functions are specific for X11 windows only so we should check
if the passed window is an X11 one, not just a MetaWindow since we're
casting to the actual type at later point.

Fixes changes part of commit e1e6534eb

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3727>
---
 src/x11/window-x11.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index b87c5072a..2ab109497 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -4439,7 +4439,7 @@ meta_window_x11_get_xwindow (MetaWindow *window)
   MetaWindowX11 *window_x11;
   MetaWindowX11Private *priv;
 
-  g_return_val_if_fail (META_IS_WINDOW (window), None);
+  g_return_val_if_fail (META_IS_WINDOW_X11 (window), None);
 
   window_x11 = META_WINDOW_X11 (window);
   priv = meta_window_x11_get_instance_private (window_x11);
@@ -4453,7 +4453,7 @@ meta_window_x11_get_xgroup_leader (MetaWindow *window)
   MetaWindowX11 *window_x11;
   MetaWindowX11Private *priv;
 
-  g_return_val_if_fail (META_IS_WINDOW (window), None);
+  g_return_val_if_fail (META_IS_WINDOW_X11 (window), None);
 
   window_x11 = META_WINDOW_X11 (window);
   priv = meta_window_x11_get_instance_private (window_x11);
@@ -4467,7 +4467,7 @@ meta_window_x11_get_user_time_window (MetaWindow *window)
   MetaWindowX11 *window_x11;
   MetaWindowX11Private *priv;
 
-  g_return_val_if_fail (META_IS_WINDOW (window), None);
+  g_return_val_if_fail (META_IS_WINDOW_X11 (window), None);
 
   window_x11 = META_WINDOW_X11 (window);
   priv = meta_window_x11_get_instance_private (window_x11);
@@ -4480,7 +4480,7 @@ meta_window_x11_get_xtransient_for (MetaWindow *window)
 {
   MetaWindow *transient_for;
 
-  g_return_val_if_fail (META_IS_WINDOW (window), None);
+  g_return_val_if_fail (META_IS_WINDOW_X11 (window), None);
 
   transient_for = meta_window_get_transient_for (window);
   if (transient_for)
-- 
2.45.0


From 3dbe3668e67f122fea9406e9a3920705ca9bf55d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Fri, 3 May 2024 16:20:48 +0200
Subject: [PATCH 16/44] ci: Run gnome-shell tests with the timeout multiplier
 set to 5

Sometimes the test runners are saturated with other work. Bump the test
timeouts by a multiplier of 5 with the hope that they now will be much
more likely to have time to finish in time.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3735>
---
 .gitlab-ci.yml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 485321eb2..c18ff6910 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -594,7 +594,7 @@ can-run-gnome-shell@x86_64:
     - .gitlab-ci/checkout-gnome-shell.sh
     - meson setup gnome-shell gnome-shell/build --prefix /usr -Dbuildtype=debugoptimized -Dman=false --werror --fatal-meson-warnings
     - sudo meson install -C gnome-shell/build
-    - dbus-run-session -- xvfb-run meson test -C gnome-shell/build --no-rebuild
+    - dbus-run-session -- xvfb-run meson test -C gnome-shell/build --no-rebuild --timeout-multiplier 5
 
 test-mutter-coverity:
   rules:
-- 
2.45.0


From b69fc15543a2cb840c413872c8f3e390649baa6e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Fri, 3 May 2024 14:28:03 +0200
Subject: [PATCH 17/44] tests/wayland: Run with G_MESSAGES_DEBUG=all

Helpful when debugging tests.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3731>
---
 src/tests/meta-wayland-test-utils.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/tests/meta-wayland-test-utils.c b/src/tests/meta-wayland-test-utils.c
index a90c05ce7..738575cd8 100644
--- a/src/tests/meta-wayland-test-utils.c
+++ b/src/tests/meta-wayland-test-utils.c
@@ -83,6 +83,9 @@ meta_wayland_test_client_new (MetaContext *context,
   g_subprocess_launcher_setenv (launcher,
                                 "WAYLAND_DISPLAY", wayland_display_name,
                                 TRUE);
+  g_subprocess_launcher_setenv (launcher,
+                                "G_MESSAGES_DEBUG", "all",
+                                TRUE);
 
   subprocess = g_subprocess_launcher_spawn (launcher,
                                             &error,
-- 
2.45.0


From 52d5758f1b91b0130c9df24253c8ef128f57aeb8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Fri, 3 May 2024 14:30:14 +0200
Subject: [PATCH 18/44] tests/wayland: Add test for mapping clone of obstructed
 window

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3731>
---
 .../xdg-toplevel-suspended.c                  | 36 +++++++++++++++++++
 src/tests/wayland-unit-tests.c                | 22 ++++++++++++
 2 files changed, 58 insertions(+)

diff --git a/src/tests/wayland-test-clients/xdg-toplevel-suspended.c b/src/tests/wayland-test-clients/xdg-toplevel-suspended.c
index 4e58d2674..59f57e3d4 100644
--- a/src/tests/wayland-test-clients/xdg-toplevel-suspended.c
+++ b/src/tests/wayland-test-clients/xdg-toplevel-suspended.c
@@ -27,6 +27,7 @@ enum
   XDG_TOPLEVEL_SUSPENDED_COMMAND_NEXT_WORKSPACE = 0,
   XDG_TOPLEVEL_SUSPENDED_COMMAND_PREV_WORKSPACE = 1,
   XDG_TOPLEVEL_SUSPENDED_COMMAND_ACTIVATE_WINDOW = 2,
+  XDG_TOPLEVEL_SUSPENDED_COMMAND_CLONE = 3,
 };
 
 static void
@@ -155,6 +156,40 @@ test_obstructed (WaylandDisplay *display)
   wait_for_no_state (surface, XDG_TOPLEVEL_STATE_SUSPENDED);
 }
 
+static void
+test_obstructed_clone (WaylandDisplay *display)
+{
+  g_autoptr (WaylandSurface) surface = NULL;
+  g_autoptr (WaylandSurface) cover_surface = NULL;
+
+  g_debug ("Testing suspended state when mapping a clone of an obstructed "
+           "window");
+
+  surface = wayland_surface_new (display, __func__, 100, 100, 0xffffffff);
+  wl_surface_commit (surface->wl_surface);
+
+  wait_for_window_shown (display, surface->wl_surface);
+  g_assert_false (wayland_surface_has_state (surface,
+                                             XDG_TOPLEVEL_STATE_SUSPENDED));
+
+  cover_surface = wayland_surface_new (display, "obstruction",
+                                       100, 100, 0xffffffff);
+  xdg_toplevel_set_maximized (cover_surface->xdg_toplevel);
+  wl_surface_commit (cover_surface->wl_surface);
+
+  wait_for_window_shown (display, cover_surface->wl_surface);
+  test_driver_sync_point (display->test_driver,
+                          XDG_TOPLEVEL_SUSPENDED_COMMAND_ACTIVATE_WINDOW,
+                          cover_surface->wl_surface);
+
+  wait_for_state (surface, XDG_TOPLEVEL_STATE_SUSPENDED);
+
+  test_driver_sync_point (display->test_driver,
+                          XDG_TOPLEVEL_SUSPENDED_COMMAND_CLONE,
+                          surface->wl_surface);
+  wait_for_no_state (surface, XDG_TOPLEVEL_STATE_SUSPENDED);
+}
+
 int
 main (int    argc,
       char **argv)
@@ -170,6 +205,7 @@ main (int    argc,
   test_minimized (display);
   test_workspace_changes (display);
   test_obstructed (display);
+  test_obstructed_clone (display);
 
   return EXIT_SUCCESS;
 }
diff --git a/src/tests/wayland-unit-tests.c b/src/tests/wayland-unit-tests.c
index 681968da2..f9ba97149 100644
--- a/src/tests/wayland-unit-tests.c
+++ b/src/tests/wayland-unit-tests.c
@@ -873,6 +873,7 @@ enum
   XDG_TOPLEVEL_SUSPENDED_COMMAND_NEXT_WORKSPACE = 0,
   XDG_TOPLEVEL_SUSPENDED_COMMAND_PREV_WORKSPACE = 1,
   XDG_TOPLEVEL_SUSPENDED_COMMAND_ACTIVATE_WINDOW = 2,
+  XDG_TOPLEVEL_SUSPENDED_COMMAND_CLONE = 3,
 };
 
 static void
@@ -914,6 +915,27 @@ on_toplevel_suspended_sync_point (MetaWaylandTestDriver *test_driver,
       now_ms = meta_display_get_current_time_roundtrip (display);
       meta_window_activate (meta_wayland_surface_get_window (surface), now_ms);
       break;
+    case XDG_TOPLEVEL_SUSPENDED_COMMAND_CLONE:
+      {
+        MetaBackend *backend = meta_context_get_backend (test_context);
+        ClutterActor *stage = meta_backend_get_stage (backend);
+        MetaWindow *window;
+        MetaWindowActor *window_actor;
+        ClutterActor *clone;
+
+        surface = wl_resource_get_user_data (surface_resource);
+        window = meta_wayland_surface_get_window (surface);
+        window_actor = meta_window_actor_from_window (window);
+
+        clone = clutter_clone_new (CLUTTER_ACTOR (window_actor));
+        clutter_actor_show (clone);
+        clutter_actor_add_child (stage, clone);
+
+        g_object_set_data_full (G_OBJECT (window), "suspend-test-clone",
+                                clone, (GDestroyNotify) clutter_actor_destroy);
+
+        break;
+      }
     }
 }
 
-- 
2.45.0


From 7a9883d5bb0f231bbf11f120ade68000c41c9aa1 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 2 May 2024 18:02:55 +0200
Subject: [PATCH 19/44] window: Move implement_showing for the next commit

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3731>
---
 src/core/window.c | 90 +++++++++++++++++++++++------------------------
 1 file changed, 45 insertions(+), 45 deletions(-)

diff --git a/src/core/window.c b/src/core/window.c
index 1411d355c..75e9bbadf 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -1783,51 +1783,6 @@ meta_window_should_be_showing (MetaWindow *window)
   return meta_window_should_be_showing_on_workspace (window, active_workspace);
 }
 
-static void
-implement_showing (MetaWindow *window,
-                   gboolean    showing)
-{
-  /* Actually show/hide the window */
-  meta_verbose ("Implement showing = %d for window %s",
-                showing, window->desc);
-
-  /* Some windows are not stackable until being showed, so add those now. */
-  if (meta_window_is_stackable (window) && !meta_window_is_in_stack (window))
-    meta_stack_add (window->display->stack, window);
-
-  if (!showing)
-    {
-      /* When we manage a new window, we normally delay placing it
-       * until it is is first shown, but if we're previewing hidden
-       * windows we might want to know where they are on the screen,
-       * so we should place the window even if we're hiding it rather
-       * than showing it.
-       * Force placing windows only when they should be already mapped,
-       * see #751887
-       */
-      if (!window->placed && window_has_buffer (window))
-        meta_window_force_placement (window, FALSE);
-
-      meta_window_hide (window);
-
-      if (!window->override_redirect)
-        sync_client_window_mapped (window);
-    }
-  else
-    {
-      if (!window->override_redirect)
-        sync_client_window_mapped (window);
-
-      meta_window_show (window);
-    }
-}
-
-void
-meta_window_update_visibility (MetaWindow  *window)
-{
-  implement_showing (window, meta_window_should_be_showing (window));
-}
-
 void
 meta_window_clear_queued (MetaWindow *window)
 {
@@ -2243,6 +2198,51 @@ meta_window_is_suspended (MetaWindow *window)
   g_assert_not_reached ();
 }
 
+static void
+implement_showing (MetaWindow *window,
+                   gboolean    showing)
+{
+  /* Actually show/hide the window */
+  meta_verbose ("Implement showing = %d for window %s",
+                showing, window->desc);
+
+  /* Some windows are not stackable until being showed, so add those now. */
+  if (meta_window_is_stackable (window) && !meta_window_is_in_stack (window))
+    meta_stack_add (window->display->stack, window);
+
+  if (!showing)
+    {
+      /* When we manage a new window, we normally delay placing it
+       * until it is is first shown, but if we're previewing hidden
+       * windows we might want to know where they are on the screen,
+       * so we should place the window even if we're hiding it rather
+       * than showing it.
+       * Force placing windows only when they should be already mapped,
+       * see #751887
+       */
+      if (!window->placed && window_has_buffer (window))
+        meta_window_force_placement (window, FALSE);
+
+      meta_window_hide (window);
+
+      if (!window->override_redirect)
+        sync_client_window_mapped (window);
+    }
+  else
+    {
+      if (!window->override_redirect)
+        sync_client_window_mapped (window);
+
+      meta_window_show (window);
+    }
+}
+
+void
+meta_window_update_visibility (MetaWindow  *window)
+{
+  implement_showing (window, meta_window_should_be_showing (window));
+}
+
 static void
 meta_window_show (MetaWindow *window)
 {
-- 
2.45.0


From e509fc7f004bf834775b30db7446df35d13e01a1 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Thu, 2 May 2024 18:03:25 +0200
Subject: [PATCH 20/44] window: Start in the activate suspend state until
 mapped

Starting the timeout to move from hidden to suspended before the window
is mapped means we don't have a previous window configufration which we
need to get the new window configuration with the suspended state.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3731>
---
 src/core/window.c | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/core/window.c b/src/core/window.c
index 75e9bbadf..759e8a748 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -599,7 +599,7 @@ meta_window_class_init (MetaWindowClass *klass)
   obj_props[PROP_SUSPEND_STATE] =
     g_param_spec_enum ("suspend-state", NULL, NULL,
                        META_TYPE_WINDOW_SUSPEND_STATE,
-                       META_WINDOW_SUSPEND_STATE_SUSPENDED,
+                       META_WINDOW_SUSPEND_STATE_ACTIVE,
                        G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
@@ -715,6 +715,9 @@ meta_window_class_init (MetaWindowClass *klass)
 static void
 meta_window_init (MetaWindow *window)
 {
+  MetaWindowPrivate *priv = meta_window_get_instance_private (window);
+
+  priv->suspend_state = META_WINDOW_SUSPEND_STATE_ACTIVE;
   window->stamp = next_window_stamp++;
   meta_prefs_add_listener (prefs_changed_callback, window);
   window->is_alive = TRUE;
@@ -990,7 +993,6 @@ static void
 meta_window_constructed (GObject *object)
 {
   MetaWindow *window = META_WINDOW (object);
-  MetaWindowPrivate *priv = meta_window_get_instance_private (window);
   MetaDisplay *display = window->display;
   MetaContext *context = meta_display_get_context (display);
   MetaBackend *backend = meta_context_get_backend (context);
@@ -1343,11 +1345,6 @@ meta_window_constructed (GObject *object)
       !window->initially_iconic)
     unminimize_window_and_all_transient_parents (window);
 
-  /* There is a slim chance we'll hit time out before a extremely slow client
-   * managed to become active, but unlikely enough. */
-  priv->suspend_state = META_WINDOW_SUSPEND_STATE_HIDDEN;
-  set_hidden_suspended_state (window);
-
   window->constructing = FALSE;
 }
 
@@ -2235,6 +2232,8 @@ implement_showing (MetaWindow *window,
 
       meta_window_show (window);
     }
+
+  update_suspend_state (window);
 }
 
 void
-- 
2.45.0


From fc623c1ed1ca81d0f26de91981d9f1aa37a80cdf Mon Sep 17 00:00:00 2001
From: Bilal Elmoussaoui <belmouss@redhat.com>
Date: Thu, 9 Nov 2023 15:29:38 +0100
Subject: [PATCH 21/44] build: Enable -Werror=shadow and fix related issues

Mostly renames or removing already defined types

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3378>
---
 cogl/cogl/cogl-onscreen.c                     | 20 ++++++++-----------
 cogl/cogl/cogl-renderer.c                     |  1 -
 cogl/cogl/winsys/cogl-onscreen-egl.c          |  5 ++---
 cogl/cogl/winsys/cogl-onscreen-glx.c          |  2 --
 meson.build                                   |  1 +
 src/backends/meta-dbus-session-manager.c      |  6 +++---
 src/backends/meta-input-capture-session.c     |  1 -
 src/backends/meta-logical-monitor.c           |  4 ++--
 src/backends/meta-monitor-config-manager.c    |  8 ++++----
 src/backends/meta-monitor-manager.c           |  8 ++++----
 src/backends/meta-screen-cast-stream-src.c    |  5 +++++
 .../meta-screen-cast-virtual-stream-src.c     |  2 --
 src/backends/native/meta-backend-native.c     | 12 +++++------
 src/backends/native/meta-kms-cursor-manager.c |  6 +++---
 .../native/meta-kms-impl-device-atomic.c      |  8 ++++----
 .../native/meta-kms-impl-device-simple.c      |  1 -
 .../native/meta-monitor-manager-native.c      | 16 +++++++--------
 .../native/meta-renderer-native-gles3.c       |  8 ++++----
 src/backends/native/meta-thread.c             |  4 ++--
 src/backends/x11/cm/meta-backend-x11-cm.c     |  1 -
 src/backends/x11/meta-seat-x11.c              | 10 +++++-----
 src/compositor/meta-shaped-texture.c          |  1 -
 src/compositor/meta-window-actor-wayland.c    |  4 ++--
 src/core/display.c                            | 16 +++++++--------
 src/core/events.c                             |  4 ----
 src/tests/clutter/conform/frame-clock.c       |  9 +++------
 .../interactive/test-cogl-shader-glsl.c       | 12 +++++------
 src/tests/cogl-test-utils.c                   | 16 +++++++--------
 .../cogl/conform/test-point-size-attribute.c  |  4 ++--
 src/tests/cogl/conform/test-point-size.c      |  4 ++--
 src/tests/meta-monitor-test-utils.c           |  4 ++--
 src/tests/native-thread.c                     | 20 +++++++++----------
 .../wayland-test-clients/fractional-scale.c   |  2 +-
 .../kms-cursor-hotplug-helper.c               | 14 ++++++-------
 .../wayland-test-clients/service-client.c     |  9 +++------
 .../subsurface-parent-unmapped.c              | 16 +++++++--------
 .../subsurface-remap-toplevel.c               |  6 +++---
 .../subsurface-reparenting.c                  | 10 +++++-----
 .../wayland-test-clients/xdg-apply-limits.c   |  6 +++---
 .../xdg-toplevel-bounds.c                     |  2 +-
 src/tests/wayland-test-clients/ycbcr.c        |  4 ++--
 src/tests/wayland-unit-tests.c                | 10 +++++-----
 src/wayland/meta-wayland-actor-surface.c      | 14 ++++++-------
 src/wayland/meta-wayland-cursor-surface.c     |  4 ----
 src/wayland/meta-wayland-dma-buf.c            |  8 ++++----
 src/wayland/meta-wayland-subsurface.c         |  6 +++---
 src/wayland/meta-wayland-tablet-tool.c        |  1 -
 src/wayland/meta-wayland-transaction.c        |  2 --
 src/wayland/meta-xwayland.c                   |  3 +--
 49 files changed, 157 insertions(+), 183 deletions(-)

diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index afb648bcd..09849607b 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -353,16 +353,14 @@ cogl_onscreen_swap_buffers_with_damage (CoglOnscreen *onscreen,
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
     {
-      CoglFrameInfo *info;
+      g_autoptr (CoglFrameInfo) pending_info = NULL;
 
       g_warn_if_fail (priv->pending_frame_infos.length == 1);
 
-      info = g_queue_pop_tail (&priv->pending_frame_infos);
+      pending_info = g_queue_pop_tail (&priv->pending_frame_infos);
 
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      g_object_unref (info);
+      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, pending_info);
+      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, pending_info);
     }
 
   priv->frame_counter++;
@@ -413,16 +411,14 @@ cogl_onscreen_swap_region (CoglOnscreen *onscreen,
 
   if (!_cogl_winsys_has_feature (COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT))
     {
-      CoglFrameInfo *info;
+      g_autoptr (CoglFrameInfo) pending_info = NULL;
 
       g_warn_if_fail (priv->pending_frame_infos.length == 1);
 
-      info = g_queue_pop_tail (&priv->pending_frame_infos);
+      pending_info = g_queue_pop_tail (&priv->pending_frame_infos);
 
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, info);
-      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, info);
-
-      g_object_unref (info);
+      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_SYNC, pending_info);
+      _cogl_onscreen_queue_event (onscreen, COGL_FRAME_EVENT_COMPLETE, pending_info);
     }
 
   priv->frame_counter++;
diff --git a/cogl/cogl/cogl-renderer.c b/cogl/cogl/cogl-renderer.c
index 8e8bc4a4f..fd4e44166 100644
--- a/cogl/cogl/cogl-renderer.c
+++ b/cogl/cogl/cogl-renderer.c
@@ -414,7 +414,6 @@ _cogl_renderer_choose_driver (CoglRenderer *renderer,
   if (driver_override != COGL_DRIVER_ANY)
     {
       gboolean found = FALSE;
-      int i;
 
       for (i = 0; i < G_N_ELEMENTS (_cogl_drivers); i++)
         {
diff --git a/cogl/cogl/winsys/cogl-onscreen-egl.c b/cogl/cogl/winsys/cogl-onscreen-egl.c
index 44010969c..dfdcfbe8f 100644
--- a/cogl/cogl/winsys/cogl-onscreen-egl.c
+++ b/cogl/cogl/winsys/cogl-onscreen-egl.c
@@ -326,13 +326,12 @@ cogl_onscreen_egl_swap_buffers_with_damage (CoglOnscreen  *onscreen,
      and just returns an error if this is not the case so we can't
      just pretend this isn't in the spec. */
   cogl_context_flush_framebuffer_state (context,
-                                        COGL_FRAMEBUFFER (onscreen),
-                                        COGL_FRAMEBUFFER (onscreen),
+                                        framebuffer,
+                                        framebuffer,
                                         COGL_FRAMEBUFFER_STATE_BIND);
 
   if (n_rectangles && priv->pf_eglSwapBuffersWithDamage)
     {
-      CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
       size_t size = n_rectangles * sizeof (int) * 4;
       int *flipped = alloca (size);
       int i;
diff --git a/cogl/cogl/winsys/cogl-onscreen-glx.c b/cogl/cogl/winsys/cogl-onscreen-glx.c
index e61089bbf..07fad363a 100644
--- a/cogl/cogl/winsys/cogl-onscreen-glx.c
+++ b/cogl/cogl/winsys/cogl-onscreen-glx.c
@@ -784,7 +784,6 @@ cogl_onscreen_glx_swap_region (CoglOnscreen  *onscreen,
 
       drawable =
         onscreen_glx->glxwin ? onscreen_glx->glxwin : onscreen_glx->xwin;
-      int i;
       for (i = 0; i < n_rectangles; i++)
         {
           int *rect = &rectangles[4 * i];
@@ -794,7 +793,6 @@ cogl_onscreen_glx_swap_region (CoglOnscreen  *onscreen,
     }
   else if (context->glBlitFramebuffer)
     {
-      int i;
       /* XXX: checkout how this state interacts with the code to use
        * glBlitFramebuffer in Neil's texture atlasing branch */
 
diff --git a/meson.build b/meson.build
index 50c751263..817ad1506 100644
--- a/meson.build
+++ b/meson.build
@@ -526,6 +526,7 @@ if buildtype != 'plain'
     '-Wno-unused-parameter',
     '-Wno-missing-field-initializers',
     '-Wno-type-limits',
+    '-Wshadow',
   ]
 
   if get_option('debug')
diff --git a/src/backends/meta-dbus-session-manager.c b/src/backends/meta-dbus-session-manager.c
index 2b611e142..5816f92fe 100644
--- a/src/backends/meta-dbus-session-manager.c
+++ b/src/backends/meta-dbus-session-manager.c
@@ -370,15 +370,15 @@ meta_dbus_session_manager_create_session (MetaDbusSessionManager  *session_manag
       GValue value = G_VALUE_INIT;
       GParamSpec *pspec;
       GType ptype;
-      gchar *error = NULL;
+      gchar *error_message = NULL;
 
       pspec = g_object_class_find_property (object_class,
                                             property_name);
       g_assert (pspec);
 
       ptype = G_PARAM_SPEC_VALUE_TYPE (pspec);
-      G_VALUE_COLLECT_INIT (&value, ptype, var_args, 0, &error);
-      g_assert (!error);
+      G_VALUE_COLLECT_INIT (&value, ptype, var_args, 0, &error_message);
+      g_assert (!error_message);
 
       g_array_append_val (names, property_name);
       g_array_append_val (values, value);
diff --git a/src/backends/meta-input-capture-session.c b/src/backends/meta-input-capture-session.c
index 044f93bba..3ffe918e3 100644
--- a/src/backends/meta-input-capture-session.c
+++ b/src/backends/meta-input-capture-session.c
@@ -1453,7 +1453,6 @@ meta_input_capture_session_process_event (MetaInputCaptureSession *session,
         ClutterScrollFinishFlags finish_flags;
         const double factor = 10.0;
         bool stop_x = false, stop_y = false;
-        double dx, dy;
 
         if (!session->eis_pointer)
           return TRUE;
diff --git a/src/backends/meta-logical-monitor.c b/src/backends/meta-logical-monitor.c
index 70d23b092..c6946e953 100644
--- a/src/backends/meta-logical-monitor.c
+++ b/src/backends/meta-logical-monitor.c
@@ -171,11 +171,11 @@ meta_logical_monitor_add_monitor (MetaLogicalMonitor *logical_monitor,
 
   for (l = logical_monitor->monitors; l; l = l->next)
     {
-      MetaMonitor *monitor = l->data;
+      MetaMonitor *other_monitor = l->data;
       GList *outputs;
       GList *l_output;
 
-      outputs = meta_monitor_get_outputs (monitor);
+      outputs = meta_monitor_get_outputs (other_monitor);
       for (l_output = outputs; l_output; l_output = l_output->next)
         {
           MetaOutput *output = l_output->data;
diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index 5fcb10b4e..358b01f15 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -1321,12 +1321,12 @@ create_for_switch_config_all_mirror (MetaMonitorConfigManager *config_manager)
 
   for (l = monitors; l; l = l->next)
     {
-      MetaMonitor *monitor = l->data;
+      MetaMonitor *other_monitor = l->data;
       MetaMonitorMode *mode = NULL;
       GList *ll;
       float scale;
 
-      for (ll = meta_monitor_get_modes (monitor); ll; ll = ll->next)
+      for (ll = meta_monitor_get_modes (other_monitor); ll; ll = ll->next)
         {
           gint mode_w, mode_h;
 
@@ -1340,10 +1340,10 @@ create_for_switch_config_all_mirror (MetaMonitorConfigManager *config_manager)
       if (!mode)
         continue;
 
-      scale = compute_scale_for_monitor (config_manager, monitor,
+      scale = compute_scale_for_monitor (config_manager, other_monitor,
                                          primary_monitor);
       best_scale = MAX (best_scale, scale);
-      monitor_configs = g_list_prepend (monitor_configs, create_monitor_config (monitor, mode));
+      monitor_configs = g_list_prepend (monitor_configs, create_monitor_config (other_monitor, mode));
     }
 
   scale_logical_monitor_width (layout_mode, best_scale,
diff --git a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
index 77743bc72..5ea06910e 100644
--- a/src/backends/meta-monitor-manager.c
+++ b/src/backends/meta-monitor-manager.c
@@ -2657,7 +2657,7 @@ create_logical_monitor_config_from_variant (MetaMonitorManager          *manager
   gboolean is_primary;
   GVariantIter *monitor_configs_iter;
   GList *monitor_configs = NULL;
-  MetaMonitorConfig *monitor_config;
+  MetaMonitorConfig *first_monitor_config;
 
   g_variant_get (logical_monitor_config_variant, LOGICAL_MONITOR_CONFIG_FORMAT,
                  &x,
@@ -2702,16 +2702,16 @@ create_logical_monitor_config_from_variant (MetaMonitorManager          *manager
       goto err;
     }
 
-  monitor_config = monitor_configs->data;
+  first_monitor_config = monitor_configs->data;
   if (!find_monitor_mode_scale (manager,
                                 layout_mode,
-                                monitor_config,
+                                first_monitor_config,
                                 scale,
                                 &scale,
                                 error))
     goto err;
 
-  if (!derive_logical_monitor_size (monitor_config, &width, &height,
+  if (!derive_logical_monitor_size (first_monitor_config, &width, &height,
                                     scale, transform, layout_mode, error))
     goto err;
 
diff --git a/src/backends/meta-screen-cast-stream-src.c b/src/backends/meta-screen-cast-stream-src.c
index 9fc872e2b..1ac87a2bb 100644
--- a/src/backends/meta-screen-cast-stream-src.c
+++ b/src/backends/meta-screen-cast-stream-src.c
@@ -17,6 +17,9 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  *
  */
+/* Till https://gitlab.freedesktop.org/pipewire/pipewire/-/issues/3915 is fixed */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wshadow"
 
 #include "config.h"
 
@@ -1826,3 +1829,5 @@ meta_screen_cast_stream_src_get_preferred_format (MetaScreenCastStreamSrc *src)
 
   return klass->get_preferred_format (src);
 }
+
+#pragma GCC diagnostic pop
diff --git a/src/backends/meta-screen-cast-virtual-stream-src.c b/src/backends/meta-screen-cast-virtual-stream-src.c
index 94fa5987c..00a0b6677 100644
--- a/src/backends/meta-screen-cast-virtual-stream-src.c
+++ b/src/backends/meta-screen-cast-virtual-stream-src.c
@@ -635,8 +635,6 @@ ensure_virtual_monitor (MetaScreenCastVirtualStreamSrc *virtual_src,
   virtual_monitor = create_virtual_monitor (virtual_src, video_format, &error);
   if (!virtual_monitor)
     {
-      MetaScreenCastStreamSrc *src = META_SCREEN_CAST_STREAM_SRC (virtual_src);
-
       g_warning ("Failed to create virtual monitor with size %dx%d: %s",
                  video_format->size.width, video_format->size.height,
                  error->message);
diff --git a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
index 7a8b89de0..e7c0beff0 100644
--- a/src/backends/native/meta-backend-native.c
+++ b/src/backends/native/meta-backend-native.c
@@ -655,7 +655,7 @@ init_gpus (MetaBackendNative  *native,
   for (l = devices; l; l = l->next)
     {
       GUdevDevice *device = l->data;
-      GError *local_error = NULL;
+      GError *device_error = NULL;
 
       if (should_ignore_device (native, device))
         {
@@ -664,25 +664,25 @@ init_gpus (MetaBackendNative  *native,
           continue;
         }
 
-      if (!add_drm_device (native, device, &local_error))
+      if (!add_drm_device (native, device, &device_error))
         {
           if (meta_backend_is_headless (backend) &&
-              g_error_matches (local_error, G_IO_ERROR,
+              g_error_matches (device_error, G_IO_ERROR,
                                G_IO_ERROR_PERMISSION_DENIED))
             {
               meta_topic (META_DEBUG_BACKEND,
                           "Ignoring unavailable gpu '%s': %s'",
                           g_udev_device_get_device_file (device),
-                          local_error->message);
+                          device_error->message);
             }
           else
             {
               g_warning ("Failed to open gpu '%s': %s",
                          g_udev_device_get_device_file (device),
-                         local_error->message);
+                         device_error->message);
             }
 
-          g_clear_error (&local_error);
+          g_clear_error (&device_error);
           continue;
         }
     }
diff --git a/src/backends/native/meta-kms-cursor-manager.c b/src/backends/native/meta-kms-cursor-manager.c
index 6873000dc..0a35c6932 100644
--- a/src/backends/native/meta-kms-cursor-manager.c
+++ b/src/backends/native/meta-kms-cursor-manager.c
@@ -475,15 +475,15 @@ update_filter_cb (MetaKmsImpl       *impl,
       for (i = 0; i < crtc_states->len; i++)
         {
           CrtcStateImpl *crtc_state_impl = g_ptr_array_index (crtc_states, i);
-          MetaKmsCrtc *crtc = crtc_state_impl->crtc;
+          MetaKmsCrtc *state_crtc = crtc_state_impl->crtc;
           MetaDrmBuffer *old_buffer = NULL;
 
-          if (meta_kms_crtc_get_device (crtc) !=
+          if (meta_kms_crtc_get_device (state_crtc) !=
               meta_kms_update_get_device (update))
             continue;
 
           update = maybe_update_cursor_plane (cursor_manager_impl,
-                                              crtc, update, &old_buffer);
+                                              state_crtc, update, &old_buffer);
           if (old_buffer)
             old_buffers = g_list_prepend (old_buffers, old_buffer);
         }
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 7812ec042..a4ffd70b6 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -672,7 +672,7 @@ process_plane_assignment (MetaKmsImplDevice  *impl_device,
           struct {
             MetaKmsPlaneProp prop;
             uint64_t value;
-          } props[] = {
+          } cursor_props[] = {
             {
               .prop = META_KMS_PLANE_PROP_HOTSPOT_X,
               .value = plane_assignment->cursor_hotspot.is_valid ?
@@ -687,12 +687,12 @@ process_plane_assignment (MetaKmsImplDevice  *impl_device,
             },
           };
 
-          for (i = 0; i < G_N_ELEMENTS (props); i++)
+          for (i = 0; i < G_N_ELEMENTS (cursor_props); i++)
             {
               if (!add_plane_property (impl_device,
                                        plane, req,
-                                       props[i].prop,
-                                       props[i].value,
+                                       cursor_props[i].prop,
+                                       cursor_props[i].value,
                                        error))
                 return FALSE;
             }
diff --git a/src/backends/native/meta-kms-impl-device-simple.c b/src/backends/native/meta-kms-impl-device-simple.c
index 9c46bbe0e..3818376dd 100644
--- a/src/backends/native/meta-kms-impl-device-simple.c
+++ b/src/backends/native/meta-kms-impl-device-simple.c
@@ -785,7 +785,6 @@ retry_page_flips (gpointer user_data)
 
   if (impl_device_simple->pending_page_flip_retries)
     {
-      GList *l;
       uint64_t earliest_retry_time_us = 0;
 
       for (l = impl_device_simple->pending_page_flip_retries; l; l = l->next)
diff --git a/src/backends/native/meta-monitor-manager-native.c b/src/backends/native/meta-monitor-manager-native.c
index c3639cd3a..628d23b8c 100644
--- a/src/backends/native/meta-monitor-manager-native.c
+++ b/src/backends/native/meta-monitor-manager-native.c
@@ -164,10 +164,10 @@ meta_monitor_manager_native_ensure_initial_config (MetaMonitorManager *manager)
 
 static void
 apply_crtc_assignments (MetaMonitorManager    *manager,
-                        MetaCrtcAssignment   **crtcs,
-                        unsigned int           n_crtcs,
-                        MetaOutputAssignment **outputs,
-                        unsigned int           n_outputs)
+                        MetaCrtcAssignment   **crtc_assignments,
+                        unsigned int           n_crtc_assignments,
+                        MetaOutputAssignment **output_assignments,
+                        unsigned int           n_output_assignments)
 {
   MetaBackend *backend = meta_monitor_manager_get_backend (manager);
   g_autoptr (GList) to_configure_outputs = NULL;
@@ -200,9 +200,9 @@ apply_crtc_assignments (MetaMonitorManager    *manager,
       to_configure_crtcs = g_list_append (to_configure_crtcs, crtc);
     }
 
-  for (i = 0; i < n_crtcs; i++)
+  for (i = 0; i < n_crtc_assignments; i++)
     {
-      MetaCrtcAssignment *crtc_assignment = crtcs[i];
+      MetaCrtcAssignment *crtc_assignment = crtc_assignments[i];
       MetaCrtc *crtc = crtc_assignment->crtc;
 
       to_configure_crtcs = g_list_remove (to_configure_crtcs, crtc);
@@ -231,8 +231,8 @@ apply_crtc_assignments (MetaMonitorManager    *manager,
               to_configure_outputs = g_list_remove (to_configure_outputs,
                                                     output);
 
-              output_assignment = meta_find_output_assignment (outputs,
-                                                               n_outputs,
+              output_assignment = meta_find_output_assignment (output_assignments,
+                                                               n_output_assignments,
                                                                output);
               meta_output_assign_crtc (output, crtc, output_assignment);
             }
diff --git a/src/backends/native/meta-renderer-native-gles3.c b/src/backends/native/meta-renderer-native-gles3.c
index 0d50de177..159e2daef 100644
--- a/src/backends/native/meta-renderer-native-gles3.c
+++ b/src/backends/native/meta-renderer-native-gles3.c
@@ -94,12 +94,12 @@ can_blit_buffer (ContextData *context_data,
 
   for (i = 0; i < context_data->buffer_support->len; i++)
     {
-      BufferTypeSupport *support =
+      BufferTypeSupport *other_support =
         &g_array_index (context_data->buffer_support, BufferTypeSupport, i);
 
-      if (support->drm_format == drm_format &&
-          support->drm_modifier == drm_modifier)
-        return support->can_blit;
+      if (other_support->drm_format == drm_format &&
+          other_support->drm_modifier == drm_modifier)
+        return other_support->can_blit;
     }
 
   if (!meta_egl_has_extensions (egl, egl_display, NULL,
diff --git a/src/backends/native/meta-thread.c b/src/backends/native/meta-thread.c
index 298cf088d..33e6c2697 100644
--- a/src/backends/native/meta-thread.c
+++ b/src/backends/native/meta-thread.c
@@ -863,12 +863,12 @@ meta_thread_flush_callbacks (MetaThread *thread)
       g_mutex_lock (&priv->callbacks_mutex);
       for (i = 0; i < main_thread_sources->len; i++)
         {
-          MetaThreadCallbackSource *source =
+          MetaThreadCallbackSource *callback_source =
             g_ptr_array_index (main_thread_sources, i);
 
           pending_callbacks =
             g_list_concat (pending_callbacks,
-                           g_steal_pointer (&source->callbacks));
+                           g_steal_pointer (&callback_source->callbacks));
         }
 
       callback_sources = g_hash_table_get_values (priv->callback_sources);
diff --git a/src/backends/x11/cm/meta-backend-x11-cm.c b/src/backends/x11/cm/meta-backend-x11-cm.c
index 12be06dc5..509dbbe72 100644
--- a/src/backends/x11/cm/meta-backend-x11-cm.c
+++ b/src/backends/x11/cm/meta-backend-x11-cm.c
@@ -408,7 +408,6 @@ meta_backend_x11_cm_handle_host_xevent (MetaBackendX11 *x11,
     {
       MetaCompositor *compositor = display->compositor;
       MetaCompositorX11 *compositor_x11 = META_COMPOSITOR_X11 (compositor);
-      Display *xdisplay = meta_backend_x11_get_xdisplay (x11);
 
       if (meta_dnd_handle_xdnd_event (backend, compositor_x11,
                                       xdisplay, event))
diff --git a/src/backends/x11/meta-seat-x11.c b/src/backends/x11/meta-seat-x11.c
index e76a9d046..45e1d4859 100644
--- a/src/backends/x11/meta-seat-x11.c
+++ b/src/backends/x11/meta-seat-x11.c
@@ -2297,7 +2297,7 @@ meta_seat_x11_translate_event (MetaSeatX11  *seat,
 
         if (clutter_input_device_get_device_type (source_device) == CLUTTER_PAD_DEVICE)
           {
-            uint32_t button, group = 0, mode = 0;
+            uint32_t pad_button, group = 0, mode = 0;
 
             /* We got these events because of the passive button grab */
             XIAllowEvents (xdisplay, xev->sourceid, XIAsyncDevice, xev->time);
@@ -2316,11 +2316,11 @@ meta_seat_x11_translate_event (MetaSeatX11  *seat,
               xev->detail -= 4;
 
             /* Pad buttons are 0-indexed */
-            button = xev->detail - 1;
+            pad_button = xev->detail - 1;
 
 #ifdef HAVE_LIBWACOM
             meta_input_device_x11_update_pad_state (device,
-                                                    button,
+                                                    pad_button,
                                                     (xi_event->evtype == XI_ButtonPress),
                                                     &group,
                                                     &mode);
@@ -2332,7 +2332,7 @@ meta_seat_x11_translate_event (MetaSeatX11  *seat,
                                                   CLUTTER_EVENT_NONE,
                                                   us2ms (xev->time),
                                                   source_device,
-                                                  button,
+                                                  pad_button,
                                                   group,
                                                   mode);
 
@@ -2345,7 +2345,7 @@ meta_seat_x11_translate_event (MetaSeatX11  *seat,
                      meta_input_device_x11_get_device_id (device),
                      clutter_input_device_get_device_name (device),
                      xev->time,
-                     button);
+                     pad_button);
             break;
           }
 
diff --git a/src/compositor/meta-shaped-texture.c b/src/compositor/meta-shaped-texture.c
index b47572b2e..1ebef0d67 100644
--- a/src/compositor/meta-shaped-texture.c
+++ b/src/compositor/meta-shaped-texture.c
@@ -853,7 +853,6 @@ do_paint_content (MetaShapedTexture   *stex,
       if (blended_tex_region)
         {
           /* 1) blended_tex_region is not empty. Paint the rectangles. */
-          int i;
           int n_rects = mtk_region_num_rectangles (blended_tex_region);
 
           for (i = 0; i < n_rects; i++)
diff --git a/src/compositor/meta-window-actor-wayland.c b/src/compositor/meta-window-actor-wayland.c
index 0b43f8eb1..e5c45cf39 100644
--- a/src/compositor/meta-window-actor-wayland.c
+++ b/src/compositor/meta-window-actor-wayland.c
@@ -255,9 +255,9 @@ meta_window_actor_wayland_rebuild_surface_tree (MetaWindowActor *actor)
 
       if (!g_list_find (surface_actors, child_actor))
         {
-          MetaSurfaceActor *surface_actor = META_SURFACE_ACTOR (child_actor);
+          MetaSurfaceActor *child_surface_actor = META_SURFACE_ACTOR (child_actor);
 
-          meta_window_actor_remove_surface_actor (actor, surface_actor);
+          meta_window_actor_remove_surface_actor (actor, child_surface_actor);
           clutter_actor_remove_child (CLUTTER_ACTOR (self->surface_container),
                                       child_actor);
         }
diff --git a/src/core/display.c b/src/core/display.c
index e0dfc7c7e..0ce1d1e1d 100644
--- a/src/core/display.c
+++ b/src/core/display.c
@@ -1900,21 +1900,21 @@ meta_display_ping_window (MetaWindow *window,
 
   for (l = display->pending_pings; l; l = l->next)
     {
-      MetaPingData *ping_data = l->data;
+      MetaPingData *pending_ping_data = l->data;
 
-      if (window == ping_data->window)
+      if (window == pending_ping_data->window)
         {
           meta_topic (META_DEBUG_PING,
                       "Window %s already is being pinged with serial %u",
-                      window->desc, ping_data->serial);
+                      window->desc, pending_ping_data->serial);
           return;
         }
 
-      if (serial == ping_data->serial)
+      if (serial == pending_ping_data->serial)
         {
           meta_warning ("Ping serial %u was reused for window %s, "
                         "previous use was for window %s.",
-                        serial, window->desc, ping_data->window->desc);
+                        serial, window->desc, pending_ping_data->window->desc);
           return;
         }
     }
@@ -3239,9 +3239,9 @@ check_fullscreen_func (gpointer data)
     {
       /* DOCK window stacking depends on the monitor's fullscreen
          status so we need to trigger a re-layering. */
-      MetaWindow *window = meta_stack_get_top (display->stack);
-      if (window)
-        meta_stack_update_layer (display->stack, window);
+      MetaWindow *top_window = meta_stack_get_top (display->stack);
+      if (top_window)
+        meta_stack_update_layer (display->stack, top_window);
 
       g_signal_emit (display, display_signals[IN_FULLSCREEN_CHANGED], 0, NULL);
     }
diff --git a/src/core/events.c b/src/core/events.c
index f766b806d..4261bfb98 100644
--- a/src/core/events.c
+++ b/src/core/events.c
@@ -333,10 +333,6 @@ meta_display_handle_event (MetaDisplay        *display,
 
   if (event_type == CLUTTER_MOTION)
     {
-      ClutterInputDevice *device;
-
-      device = clutter_event_get_device (event);
-
 #ifdef HAVE_WAYLAND
       if (wayland_compositor)
         {
diff --git a/src/tests/clutter/conform/frame-clock.c b/src/tests/clutter/conform/frame-clock.c
index 7522c7f8f..e78aafb52 100644
--- a/src/tests/clutter/conform/frame-clock.c
+++ b/src/tests/clutter/conform/frame-clock.c
@@ -496,9 +496,7 @@ before_frame_frame_clock_before_frame (ClutterFrameClock *frame_clock,
                                        ClutterFrame      *frame,
                                        gpointer           user_data)
 {
-  int64_t *expected_frame_count = user_data;
-
-  g_assert_cmpint (*expected_frame_count, ==, clutter_frame_get_count (frame));
+  g_assert_cmpint (expected_frame_count, ==, clutter_frame_get_count (frame));
 }
 
 static ClutterFrameResult
@@ -506,12 +504,11 @@ before_frame_frame_clock_frame (ClutterFrameClock *frame_clock,
                                 ClutterFrame      *frame,
                                 gpointer           user_data)
 {
-  int64_t *expected_frame_count = user_data;
   ClutterFrameInfo frame_info;
 
-  g_assert_cmpint (*expected_frame_count, ==, clutter_frame_get_count (frame));
+  g_assert_cmpint (expected_frame_count, ==, clutter_frame_get_count (frame));
 
-  (*expected_frame_count)++;
+  expected_frame_count++;
 
   init_frame_info (&frame_info, g_get_monotonic_time ());
   clutter_frame_clock_notify_presented (frame_clock, &frame_info);
diff --git a/src/tests/clutter/interactive/test-cogl-shader-glsl.c b/src/tests/clutter/interactive/test-cogl-shader-glsl.c
index a8ff34453..4930711da 100644
--- a/src/tests/clutter/interactive/test-cogl-shader-glsl.c
+++ b/src/tests/clutter/interactive/test-cogl-shader-glsl.c
@@ -191,7 +191,7 @@ set_shader_num (int new_no)
 {
   CoglShader *shader;
   CoglProgram *program;
-  CoglPipeline *pipeline;
+  CoglPipeline *shader_pipeline;
   CoglContext *ctx =
     clutter_backend_get_cogl_context (clutter_get_default_backend ());
   int image_width = cogl_texture_get_width (redhand);
@@ -202,7 +202,7 @@ set_shader_num (int new_no)
            new_no,
            shaders[new_no].name);
 
-  pipeline = cogl_pipeline_new (ctx);
+  shader_pipeline = cogl_pipeline_new (ctx);
 
   shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
   cogl_shader_source (shader, shaders[new_no].source);
@@ -226,7 +226,7 @@ set_shader_num (int new_no)
   uniform_no = cogl_program_get_uniform_location (program, "y_step");
   cogl_program_set_uniform_1f (program, uniform_no, 1.0f / image_height);
 
-  cogl_pipeline_set_user_program (pipeline, program);
+  cogl_pipeline_set_user_program (shader_pipeline, program);
   g_object_unref (program);
 
   shader_no = new_no;
@@ -314,7 +314,7 @@ test_cogl_shader_glsl_main (int argc, char *argv[])
   char *file;
   GError *error;
   ClutterColor stage_color = { 0x61, 0x64, 0x8c, 0xff };
-  CoglPipeline *pipeline;
+  CoglPipeline *shader_pipeline;
   CoglContext *ctx =
     clutter_backend_get_cogl_context (clutter_get_default_backend ());
 
@@ -333,8 +333,8 @@ test_cogl_shader_glsl_main (int argc, char *argv[])
   if (redhand == NULL)
     g_error ("image load failed: %s", error->message);
 
-  pipeline = cogl_pipeline_new (ctx);
-  cogl_pipeline_set_layer_texture (pipeline, 0, redhand);
+  shader_pipeline = cogl_pipeline_new (ctx);
+  cogl_pipeline_set_layer_texture (shader_pipeline, 0, redhand);
 
   set_shader_num (0);
   g_signal_connect (actor, "paint", G_CALLBACK (on_paint), NULL);
diff --git a/src/tests/cogl-test-utils.c b/src/tests/cogl-test-utils.c
index 4795385be..763016df9 100644
--- a/src/tests/cogl-test-utils.c
+++ b/src/tests/cogl-test-utils.c
@@ -78,14 +78,14 @@ test_utils_compare_pixel (const uint8_t *screen_pixel,
 }
 
 void
-test_utils_check_pixel (CoglFramebuffer *test_fb,
+test_utils_check_pixel (CoglFramebuffer *framebuffer,
                         int              x,
                         int              y,
                         uint32_t         expected_pixel)
 {
   uint8_t pixel[4];
 
-  cogl_framebuffer_read_pixels (test_fb,
+  cogl_framebuffer_read_pixels (framebuffer,
                                 x, y, 1, 1,
                                 COGL_PIXEL_FORMAT_RGBA_8888_PRE,
                                 pixel);
@@ -94,14 +94,14 @@ test_utils_check_pixel (CoglFramebuffer *test_fb,
 }
 
 void
-test_utils_check_pixel_and_alpha (CoglFramebuffer *test_fb,
+test_utils_check_pixel_and_alpha (CoglFramebuffer *framebuffer,
                                   int              x,
                                   int              y,
                                   uint32_t         expected_pixel)
 {
   uint8_t pixel[4];
 
-  cogl_framebuffer_read_pixels (test_fb,
+  cogl_framebuffer_read_pixels (framebuffer,
                                 x, y, 1, 1,
                                 COGL_PIXEL_FORMAT_RGBA_8888_PRE,
                                 pixel);
@@ -110,7 +110,7 @@ test_utils_check_pixel_and_alpha (CoglFramebuffer *test_fb,
 }
 
 void
-test_utils_check_pixel_rgb (CoglFramebuffer *test_fb,
+test_utils_check_pixel_rgb (CoglFramebuffer *framebuffer,
                             int              x,
                             int              y,
                             int              r,
@@ -124,14 +124,14 @@ test_utils_check_pixel_rgb (CoglFramebuffer *test_fb,
   g_return_if_fail (g <= 0xFF);
   g_return_if_fail (b <= 0xFF);
 
-  test_utils_check_pixel (test_fb, x, y,
+  test_utils_check_pixel (framebuffer, x, y,
                           (((guint32) r) << 24) |
                           (((guint32) g) << 16) |
                           (((guint32) b) << 8));
 }
 
 void
-test_utils_check_region (CoglFramebuffer *test_fb,
+test_utils_check_region (CoglFramebuffer *framebuffer,
                          int              x,
                          int              y,
                          int              width,
@@ -141,7 +141,7 @@ test_utils_check_region (CoglFramebuffer *test_fb,
   uint8_t *pixels, *p;
 
   pixels = p = g_malloc (width * height * 4);
-  cogl_framebuffer_read_pixels (test_fb,
+  cogl_framebuffer_read_pixels (framebuffer,
                                 x,
                                 y,
                                 width,
diff --git a/src/tests/cogl/conform/test-point-size-attribute.c b/src/tests/cogl/conform/test-point-size-attribute.c
index 063b4ac9c..d3a9489f1 100644
--- a/src/tests/cogl/conform/test-point-size-attribute.c
+++ b/src/tests/cogl/conform/test-point-size-attribute.c
@@ -33,7 +33,7 @@ calc_coord_offset (int pos, int pos_index, int point_size)
 }
 
 static void
-verify_point_size (CoglFramebuffer *test_fb,
+verify_point_size (CoglFramebuffer *framebuffer,
                    int x_pos,
                    int y_pos,
                    int point_size)
@@ -46,7 +46,7 @@ verify_point_size (CoglFramebuffer *test_fb,
         gboolean in_point = x >= 1 && x <= 2 && y >= 1 && y <= 2;
         uint32_t expected_pixel = in_point ? 0x00ff00ff : 0xff0000ff;
 
-        test_utils_check_pixel (test_fb,
+        test_utils_check_pixel (framebuffer,
                                 calc_coord_offset (x_pos, x, point_size),
                                 calc_coord_offset (y_pos, y, point_size),
                                 expected_pixel);
diff --git a/src/tests/cogl/conform/test-point-size.c b/src/tests/cogl/conform/test-point-size.c
index c734a3dfd..cf9fe0f75 100644
--- a/src/tests/cogl/conform/test-point-size.c
+++ b/src/tests/cogl/conform/test-point-size.c
@@ -25,7 +25,7 @@ calc_coord_offset (int pos, int pos_index, int point_size)
 }
 
 static void
-verify_point_size (CoglFramebuffer *test_fb,
+verify_point_size (CoglFramebuffer *framebuffer,
                    int x_pos,
                    int y_pos,
                    int point_size)
@@ -38,7 +38,7 @@ verify_point_size (CoglFramebuffer *test_fb,
         gboolean in_point = x >= 1 && x <= 2 && y >= 1 && y <= 2;
         uint32_t expected_pixel = in_point ? 0x00ff00ff : 0xff0000ff;
 
-        test_utils_check_pixel (test_fb,
+        test_utils_check_pixel (framebuffer,
                                 calc_coord_offset (x_pos, x, point_size),
                                 calc_coord_offset (y_pos, y, point_size),
                                 expected_pixel);
diff --git a/src/tests/meta-monitor-test-utils.c b/src/tests/meta-monitor-test-utils.c
index d7d88f6a1..4b3dde12c 100644
--- a/src/tests/meta-monitor-test-utils.c
+++ b/src/tests/meta-monitor-test-utils.c
@@ -543,10 +543,10 @@ meta_check_monitor_configuration (MetaContext           *context,
   all_crtcs = NULL;
   for (l = meta_backend_get_gpus (backend); l; l = l->next)
     {
-      MetaGpu *gpu = l->data;
+      MetaGpu *current_gpu = l->data;
 
       all_crtcs = g_list_concat (all_crtcs,
-                                 g_list_copy (meta_gpu_get_crtcs (gpu)));
+                                 g_list_copy (meta_gpu_get_crtcs (current_gpu)));
     }
 
   for (i = 0; i < expect->n_logical_monitors; i++)
diff --git a/src/tests/native-thread.c b/src/tests/native-thread.c
index abe944b6e..6f07111cf 100644
--- a/src/tests/native-thread.c
+++ b/src/tests/native-thread.c
@@ -1080,7 +1080,7 @@ meta_test_thread_change_thread_type (void)
   MetaThread *thread;
   g_autoptr (GError) error = NULL;
   GThread *main_thread;
-  GThread *test_thread;
+  GThread *thread_test;
 
   thread = g_initable_new (META_TYPE_THREAD_TEST,
                            NULL, &error,
@@ -1094,27 +1094,27 @@ meta_test_thread_change_thread_type (void)
 
   main_thread = g_thread_self ();
 
-  test_thread = main_thread;
-  meta_thread_post_impl_task (thread, assert_not_thread, &test_thread, NULL,
+  thread_test = main_thread;
+  meta_thread_post_impl_task (thread, assert_not_thread, &thread_test, NULL,
                               NULL, NULL);
 
   meta_thread_reset_thread_type (thread, META_THREAD_TYPE_USER);
-  g_assert_null (test_thread);
+  g_assert_null (thread_test);
 
-  test_thread = main_thread;
-  meta_thread_post_impl_task (thread, assert_thread, &test_thread, NULL,
+  thread_test = main_thread;
+  meta_thread_post_impl_task (thread, assert_thread, &thread_test, NULL,
                               NULL, NULL);
 
   meta_thread_reset_thread_type (thread, META_THREAD_TYPE_KERNEL);
-  g_assert_null (test_thread);
+  g_assert_null (thread_test);
 
-  test_thread = main_thread;
-  meta_thread_post_impl_task (thread, assert_not_thread, &test_thread, NULL,
+  thread_test = main_thread;
+  meta_thread_post_impl_task (thread, assert_not_thread, &thread_test, NULL,
                               NULL, NULL);
 
   g_object_unref (thread);
   g_assert_null (thread);
-  g_assert_null (test_thread);
+  g_assert_null (thread_test);
 }
 
 static GVariant *
diff --git a/src/tests/wayland-test-clients/fractional-scale.c b/src/tests/wayland-test-clients/fractional-scale.c
index 8594bd9ed..ebe41f8b9 100644
--- a/src/tests/wayland-test-clients/fractional-scale.c
+++ b/src/tests/wayland-test-clients/fractional-scale.c
@@ -122,7 +122,7 @@ static const struct xdg_surface_listener xdg_surface_listener = {
 };
 
 static void handle_preferred_scale (void                          *data,
-                                    struct wp_fractional_scale_v1 *fractional_scale_obj,
+                                    struct wp_fractional_scale_v1 *fractional_scale,
                                     uint32_t                       wire_scale)
 {
   WaylandDisplay *display = data;
diff --git a/src/tests/wayland-test-clients/kms-cursor-hotplug-helper.c b/src/tests/wayland-test-clients/kms-cursor-hotplug-helper.c
index abd515f2f..65b7e7c8a 100644
--- a/src/tests/wayland-test-clients/kms-cursor-hotplug-helper.c
+++ b/src/tests/wayland-test-clients/kms-cursor-hotplug-helper.c
@@ -100,7 +100,7 @@ static void
 pointer_handle_enter (void              *data,
                       struct wl_pointer *pointer,
                       uint32_t           serial,
-                      struct wl_surface *surface,
+                      struct wl_surface *wl_surface,
                       wl_fixed_t         sx,
                       wl_fixed_t         sy)
 {
@@ -125,7 +125,7 @@ static void
 pointer_handle_leave (void              *data,
                       struct wl_pointer *pointer,
                       uint32_t           serial,
-                      struct wl_surface *surface)
+                      struct wl_surface *wl_surface)
 {
 }
 
@@ -167,12 +167,12 @@ static const struct wl_pointer_listener pointer_listener = {
 
 static void
 seat_handle_capabilities (void                    *data,
-                          struct wl_seat          *wl_seat,
+                          struct wl_seat          *seat,
                           enum wl_seat_capability  caps)
 {
   if (caps & WL_SEAT_CAPABILITY_POINTER)
     {
-      wl_pointer = wl_seat_get_pointer (wl_seat);
+      wl_pointer = wl_seat_get_pointer (seat);
       wl_pointer_add_listener (wl_pointer, &pointer_listener, NULL);
     }
 }
@@ -249,14 +249,14 @@ main (int    argc,
       char **argv)
 {
   g_autoptr (WaylandDisplay) display = NULL;
-  struct wl_registry *wl_registry;
+  struct wl_registry *registry;
   struct xdg_toplevel *xdg_toplevel;
   struct xdg_surface *xdg_surface;
   struct wl_cursor_theme *cursor_theme;
 
   display = wayland_display_new (WAYLAND_DISPLAY_CAPABILITY_TEST_DRIVER);
-  wl_registry = wl_display_get_registry (display->display);
-  wl_registry_add_listener (wl_registry, &registry_listener, display);
+  registry = wl_display_get_registry (display->display);
+  wl_registry_add_listener (registry, &registry_listener, display);
   wl_display_roundtrip (display->display);
 
   g_signal_connect (display, "sync-event", G_CALLBACK (on_sync_event), NULL);
diff --git a/src/tests/wayland-test-clients/service-client.c b/src/tests/wayland-test-clients/service-client.c
index 44c645be8..568245ed6 100644
--- a/src/tests/wayland-test-clients/service-client.c
+++ b/src/tests/wayland-test-clients/service-client.c
@@ -32,9 +32,6 @@ typedef enum _ServiceClientType
   SERVICE_CLIENT_TYPE_PORTAL_BACKEND,
 } ServiceClientType;
 
-static WaylandDisplay *display;
-static WaylandSurface *surface;
-
 static void
 on_sync_event (WaylandDisplay *display,
                uint32_t        serial,
@@ -51,6 +48,9 @@ main (int    argc,
   g_autoptr (MetaDBusServiceChannel) service_channel = NULL;
   g_autoptr (GVariant) fd_variant = NULL;
   g_autoptr (GUnixFDList) fd_list = NULL;
+  g_autoptr (WaylandDisplay) display = NULL;
+  g_autoptr (WaylandSurface) surface = NULL;
+
   int fd;
   struct wl_display *wayland_display;
   uint32_t last_sync_event = UINT32_MAX;
@@ -89,7 +89,4 @@ main (int    argc,
 
   while (last_sync_event != 1)
     wayland_display_dispatch (display);
-
-  g_object_unref (surface);
-  g_object_unref (display);
 }
diff --git a/src/tests/wayland-test-clients/subsurface-parent-unmapped.c b/src/tests/wayland-test-clients/subsurface-parent-unmapped.c
index 510138ab8..8378143e5 100644
--- a/src/tests/wayland-test-clients/subsurface-parent-unmapped.c
+++ b/src/tests/wayland-test-clients/subsurface-parent-unmapped.c
@@ -23,8 +23,8 @@
 
 #include "wayland-test-client-utils.h"
 
-static struct wl_seat *seat;
-static struct wl_pointer *pointer;
+static struct wl_seat *wl_seat;
+static struct wl_pointer *wl_pointer;
 
 static struct wl_surface *toplevel_surface;
 static struct xdg_surface *toplevel_xdg_surface;
@@ -183,7 +183,7 @@ pointer_handle_button (void              *data,
   xdg_popup = xdg_surface_get_popup (popup_xdg_surface, toplevel_xdg_surface,
                                      positioner);
   xdg_positioner_destroy (positioner);
-  xdg_popup_grab (xdg_popup, seat, serial);
+  xdg_popup_grab (xdg_popup, wl_seat, serial);
   wl_surface_commit (popup_surface);
 
   if (click_count == 1)
@@ -218,15 +218,15 @@ static const struct wl_pointer_listener pointer_listener = {
 
 static void
 seat_handle_capabilities (void                    *data,
-                          struct wl_seat          *wl_seat,
+                          struct wl_seat          *seat,
                           enum wl_seat_capability  caps)
 {
   WaylandDisplay *display = data;
 
   if (caps & WL_SEAT_CAPABILITY_POINTER)
     {
-      pointer = wl_seat_get_pointer (wl_seat);
-      wl_pointer_add_listener (pointer, &pointer_listener, display);
+      wl_pointer = wl_seat_get_pointer (seat);
+      wl_pointer_add_listener (wl_pointer, &pointer_listener, display);
     }
 }
 
@@ -271,8 +271,8 @@ handle_registry_global (void               *data,
 
   if (strcmp (interface, "wl_seat") == 0)
     {
-      seat = wl_registry_bind (registry, id, &wl_seat_interface, 1);
-      wl_seat_add_listener (seat, &seat_listener, display);
+      wl_seat = wl_registry_bind (registry, id, &wl_seat_interface, 1);
+      wl_seat_add_listener (wl_seat, &seat_listener, display);
     }
 }
 
diff --git a/src/tests/wayland-test-clients/subsurface-remap-toplevel.c b/src/tests/wayland-test-clients/subsurface-remap-toplevel.c
index b16ff0cc5..953680f8a 100644
--- a/src/tests/wayland-test-clients/subsurface-remap-toplevel.c
+++ b/src/tests/wayland-test-clients/subsurface-remap-toplevel.c
@@ -96,16 +96,16 @@ draw_subsurface (WaylandDisplay    *display,
 
 static void
 handle_xdg_toplevel_configure (void                *data,
-                               struct xdg_toplevel *xdg_toplevel,
+                               struct xdg_toplevel *test_xdg_toplevel,
                                int32_t              width,
                                int32_t              height,
-                               struct wl_array     *state)
+                               struct wl_array     *configure_state)
 {
 }
 
 static void
 handle_xdg_toplevel_close(void                *data,
-                          struct xdg_toplevel *xdg_toplevel)
+                          struct xdg_toplevel *test_xdg_toplevel)
 {
   g_assert_not_reached ();
 }
diff --git a/src/tests/wayland-test-clients/subsurface-reparenting.c b/src/tests/wayland-test-clients/subsurface-reparenting.c
index c10ec67df..5af9642e8 100644
--- a/src/tests/wayland-test-clients/subsurface-reparenting.c
+++ b/src/tests/wayland-test-clients/subsurface-reparenting.c
@@ -61,16 +61,16 @@ draw_subsurface (WaylandDisplay *display)
 
 static void
 handle_xdg_toplevel_configure (void                *data,
-                               struct xdg_toplevel *xdg_toplevel,
+                               struct xdg_toplevel *test_xdg_toplevel,
                                int32_t              width,
                                int32_t              height,
-                               struct wl_array     *state)
+                               struct wl_array     *configure_state)
 {
 }
 
 static void
 handle_xdg_toplevel_close(void                *data,
-                          struct xdg_toplevel *xdg_toplevel)
+                          struct xdg_toplevel *test_xdg_toplevel)
 {
   g_assert_not_reached ();
 }
@@ -139,7 +139,7 @@ static const struct wl_callback_listener frame_listener = {
 
 static void
 handle_xdg_surface_configure (void               *data,
-                              struct xdg_surface *xdg_surface,
+                              struct xdg_surface *test_xdg_surface,
                               uint32_t            serial)
 {
   WaylandDisplay *display = data;
@@ -161,7 +161,7 @@ handle_xdg_surface_configure (void               *data,
       return;
     }
 
-  xdg_surface_ack_configure (xdg_surface, serial);
+  xdg_surface_ack_configure (test_xdg_surface, serial);
   frame_callback = wl_surface_frame (surface);
   wl_callback_add_listener (frame_callback, &frame_listener, display);
   wl_surface_commit (surface);
diff --git a/src/tests/wayland-test-clients/xdg-apply-limits.c b/src/tests/wayland-test-clients/xdg-apply-limits.c
index 96c3a04e6..5e4690e71 100644
--- a/src/tests/wayland-test-clients/xdg-apply-limits.c
+++ b/src/tests/wayland-test-clients/xdg-apply-limits.c
@@ -97,16 +97,16 @@ draw_subsurface (WaylandDisplay    *display,
 
 static void
 handle_xdg_toplevel_configure (void                *data,
-                               struct xdg_toplevel *xdg_toplevel,
+                               struct xdg_toplevel *test_xdg_toplevel,
                                int32_t              width,
                                int32_t              height,
-                               struct wl_array     *state)
+                               struct wl_array     *configure_state)
 {
 }
 
 static void
 handle_xdg_toplevel_close (void                *data,
-                           struct xdg_toplevel *xdg_toplevel)
+                           struct xdg_toplevel *test_xdg_toplevel)
 {
   g_assert_not_reached ();
 }
diff --git a/src/tests/wayland-test-clients/xdg-toplevel-bounds.c b/src/tests/wayland-test-clients/xdg-toplevel-bounds.c
index 4c5fed710..2c870ae84 100644
--- a/src/tests/wayland-test-clients/xdg-toplevel-bounds.c
+++ b/src/tests/wayland-test-clients/xdg-toplevel-bounds.c
@@ -59,7 +59,7 @@ handle_xdg_toplevel_configure (void                *data,
                                struct xdg_toplevel *xdg_toplevel,
                                int32_t              width,
                                int32_t              height,
-                               struct wl_array     *state)
+                               struct wl_array     *configure_state)
 {
 }
 
diff --git a/src/tests/wayland-test-clients/ycbcr.c b/src/tests/wayland-test-clients/ycbcr.c
index ba71f3e7a..8f2404191 100644
--- a/src/tests/wayland-test-clients/ycbcr.c
+++ b/src/tests/wayland-test-clients/ycbcr.c
@@ -25,8 +25,6 @@
 #include "wayland-test-client-utils.h"
 
 static struct wl_surface *surface;
-static struct xdg_surface *xdg_surface;
-static struct xdg_toplevel *xdg_toplevel;
 
 static gboolean waiting_for_configure = FALSE;
 
@@ -191,6 +189,8 @@ main (int    argc,
       char **argv)
 {
   g_autoptr (WaylandDisplay) display = NULL;
+  struct xdg_surface *xdg_surface;
+  struct xdg_toplevel *xdg_toplevel;
   display = wayland_display_new (WAYLAND_DISPLAY_CAPABILITY_TEST_DRIVER);
 
   surface = wl_compositor_create_surface (display->compositor);
diff --git a/src/tests/wayland-unit-tests.c b/src/tests/wayland-unit-tests.c
index f9ba97149..9ebe2ccb0 100644
--- a/src/tests/wayland-unit-tests.c
+++ b/src/tests/wayland-unit-tests.c
@@ -423,13 +423,13 @@ on_window_added (MetaStack  *stack,
 
 static void
 on_window_actor_destroyed (MetaWindowActor       *actor,
-                           MetaWaylandTestDriver *test_driver)
+                           MetaWaylandTestDriver *driver)
 {
-  meta_wayland_test_driver_emit_sync_event (test_driver, 0);
+  meta_wayland_test_driver_emit_sync_event (driver, 0);
 }
 
 static void
-on_unmap_sync_point (MetaWaylandTestDriver *test_driver,
+on_unmap_sync_point (MetaWaylandTestDriver *driver,
                      unsigned int           sequence,
                      struct wl_resource    *surface_resource,
                      struct wl_client      *wl_client)
@@ -456,7 +456,7 @@ on_unmap_sync_point (MetaWaylandTestDriver *test_driver,
       MetaWindowActor *window_actor = meta_window_actor_from_actor (actor);
       g_signal_connect (window_actor, "destroy",
                         G_CALLBACK (on_window_actor_destroyed),
-                        test_driver);
+                        driver);
     }
   else if (sequence == 1)
     {
@@ -877,7 +877,7 @@ enum
 };
 
 static void
-on_toplevel_suspended_sync_point (MetaWaylandTestDriver *test_driver,
+on_toplevel_suspended_sync_point (MetaWaylandTestDriver *driver,
                                   unsigned int           sequence,
                                   struct wl_resource    *surface_resource,
                                   struct wl_client      *wl_client)
diff --git a/src/wayland/meta-wayland-actor-surface.c b/src/wayland/meta-wayland-actor-surface.c
index ec6c72c29..4b4702ead 100644
--- a/src/wayland/meta-wayland-actor-surface.c
+++ b/src/wayland/meta-wayland-actor-surface.c
@@ -277,10 +277,10 @@ meta_wayland_actor_surface_real_sync_actor_state (MetaWaylandActorSurface *actor
   META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->applied_state,
                                            subsurface_surface)
     {
-      MetaWaylandActorSurface *actor_surface;
+      MetaWaylandActorSurface *actor_subsurface;
 
-      actor_surface = META_WAYLAND_ACTOR_SURFACE (subsurface_surface->role);
-      meta_wayland_actor_surface_sync_actor_state (actor_surface);
+      actor_subsurface = META_WAYLAND_ACTOR_SURFACE (subsurface_surface->role);
+      meta_wayland_actor_surface_sync_actor_state (actor_subsurface);
     }
 }
 
@@ -419,11 +419,11 @@ meta_wayland_actor_surface_reset_actor (MetaWaylandActorSurface *actor_surface)
   META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->applied_state,
                                            subsurface_surface)
     {
-      MetaWaylandActorSurface *actor_surface;
+      MetaWaylandActorSurface *actor_subsurface;
 
-      actor_surface = META_WAYLAND_ACTOR_SURFACE (subsurface_surface->role);
-      meta_wayland_actor_surface_reset_actor (actor_surface);
-      meta_wayland_actor_surface_sync_actor_state (actor_surface);
+      actor_subsurface = META_WAYLAND_ACTOR_SURFACE (subsurface_surface->role);
+      meta_wayland_actor_surface_reset_actor (actor_subsurface);
+      meta_wayland_actor_surface_sync_actor_state (actor_subsurface);
     }
 
   clear_surface_actor (actor_surface);
diff --git a/src/wayland/meta-wayland-cursor-surface.c b/src/wayland/meta-wayland-cursor-surface.c
index 87a8895c8..6851b3408 100644
--- a/src/wayland/meta-wayland-cursor-surface.c
+++ b/src/wayland/meta-wayland-cursor-surface.c
@@ -95,10 +95,6 @@ cursor_sprite_prepare_at (MetaCursorSprite         *cursor_sprite,
 
   if (!meta_wayland_surface_is_xwayland (surface))
     {
-      MetaWaylandSurfaceRole *surface_role =
-        META_WAYLAND_SURFACE_ROLE (cursor_surface);
-      MetaWaylandSurface *surface =
-        meta_wayland_surface_role_get_surface (surface_role);
       MetaContext *context =
         meta_wayland_compositor_get_context (surface->compositor);
       MetaBackend *backend = meta_context_get_backend (context);
diff --git a/src/wayland/meta-wayland-dma-buf.c b/src/wayland/meta-wayland-dma-buf.c
index 5e4ee671c..499e08662 100644
--- a/src/wayland/meta-wayland-dma-buf.c
+++ b/src/wayland/meta-wayland-dma-buf.c
@@ -462,15 +462,15 @@ meta_wayland_dma_buf_realize_texture (MetaWaylandBuffer  *buffer,
           CoglEglImageFlags flags;
           CoglTexture *cogl_texture;
           uint32_t drm_format = 0;
-          const MetaFormatInfo *format_info;
+          const MetaFormatInfo *plane_format_info;
           int plane_index = mt_format_info->plane_indices[i];
           CoglPixelFormat subformat = mt_format_info->subformats[i];
           int horizontal_factor = mt_format_info->hsub[i];
           int vertical_factor = mt_format_info->vsub[i];
 
-          format_info = meta_format_info_from_cogl_format (subformat);
-          g_return_val_if_fail (format_info != NULL, FALSE);
-          drm_format = format_info->drm_format;
+          plane_format_info = meta_format_info_from_cogl_format (subformat);
+          g_return_val_if_fail (plane_format_info != NULL, FALSE);
+          drm_format = plane_format_info->drm_format;
 
           egl_image = meta_egl_create_dmabuf_image (egl,
                                                     egl_display,
diff --git a/src/wayland/meta-wayland-subsurface.c b/src/wayland/meta-wayland-subsurface.c
index fd9df170b..4f2ae6df6 100644
--- a/src/wayland/meta-wayland-subsurface.c
+++ b/src/wayland/meta-wayland-subsurface.c
@@ -132,10 +132,10 @@ meta_wayland_subsurface_union_geometry (MetaWaylandSubsurface *subsurface,
   META_WAYLAND_SURFACE_FOREACH_SUBSURFACE (&surface->applied_state,
                                            subsurface_surface)
     {
-      MetaWaylandSubsurface *subsurface;
+      MetaWaylandSubsurface *sub_surface;
 
-      subsurface = META_WAYLAND_SUBSURFACE (subsurface_surface->role);
-      meta_wayland_subsurface_union_geometry (subsurface,
+      sub_surface = META_WAYLAND_SUBSURFACE (subsurface_surface->role);
+      meta_wayland_subsurface_union_geometry (sub_surface,
                                               parent_x + geometry.x,
                                               parent_y + geometry.y,
                                               out_geometry);
diff --git a/src/wayland/meta-wayland-tablet-tool.c b/src/wayland/meta-wayland-tablet-tool.c
index c262391f5..7a0ed38d6 100644
--- a/src/wayland/meta-wayland-tablet-tool.c
+++ b/src/wayland/meta-wayland-tablet-tool.c
@@ -356,7 +356,6 @@ meta_wayland_tablet_tool_set_focus (MetaWaylandTabletTool *tool,
 
       if (!wl_list_empty (l))
         {
-          struct wl_client *client = wl_resource_get_client (tool->focus_surface->resource);
           struct wl_display *display = wl_client_get_display (client);
 
           tool->proximity_serial = wl_display_next_serial (display);
diff --git a/src/wayland/meta-wayland-transaction.c b/src/wayland/meta-wayland-transaction.c
index 17d702926..adcac6659 100644
--- a/src/wayland/meta-wayland-transaction.c
+++ b/src/wayland/meta-wayland-transaction.c
@@ -456,8 +456,6 @@ meta_wayland_transaction_commit (MetaWaylandTransaction *transaction)
     {
       if (surface->transaction.first_committed)
         {
-          MetaWaylandTransactionEntry *entry;
-
           entry = g_hash_table_lookup (surface->transaction.last_committed->entries,
                                        surface);
           entry->next_transaction = transaction;
diff --git a/src/wayland/meta-xwayland.c b/src/wayland/meta-xwayland.c
index ea9c27d74..3366f11ad 100644
--- a/src/wayland/meta-xwayland.c
+++ b/src/wayland/meta-xwayland.c
@@ -415,6 +415,7 @@ xserver_died (GObject      *source,
         return;
 
       g_warning ("Failed to finish waiting for Xwayland: %s", error->message);
+      g_clear_error (&error);
     }
 
   x11_display_policy =
@@ -433,8 +434,6 @@ xserver_died (GObject      *source,
     }
   else if (x11_display_policy == META_X11_DISPLAY_POLICY_ON_DEMAND)
     {
-      g_autoptr (GError) error = NULL;
-
       if (display->x11_display)
         meta_display_shutdown_x11 (display);
 
-- 
2.45.0


From 6819296e8186bfe588e4ed9c6a4c40859821a89e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 15 Apr 2024 12:05:26 +0200
Subject: [PATCH 22/44] ci: Build our own gtk3 containing unreleased bug fix

Contains https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/7139 which
is needed for test suite improvements.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3700>
---
 .gitlab-ci.yml | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index c18ff6910..0f6ec8464 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -85,7 +85,7 @@ variables:
     - .skip-git-clone
   variables:
     FDO_DISTRIBUTION_VERSION: 40
-    BASE_TAG: '2024-04-29.0'
+    BASE_TAG: '2024-05-02.0'
     MUTTER_USER: 'meta-user'
     FDO_DISTRIBUTION_PACKAGES:
       asciidoc
@@ -131,7 +131,13 @@ variables:
 
       rpm -e --nodeps gnome-bluetooth-libs-devel \
                       mutter mutter-devel \
-                      gnome-shell
+                      gnome-shell \
+                      gtk3
+
+      # Contains fixes needed for tests not included in 3.24.33
+      ./.gitlab-ci/install-meson-project.sh \
+        https://gitlab.gnome.org/GNOME/gtk.git \
+        gtk-3-24 46fe3224dd771b91e6976d5a632b452e2179a4f0
 
       # Work-around for podman-push aborting on permission issue
       # https://gitlab.gnome.org/Infrastructure/Infrastructure/-/issues/1247
-- 
2.45.0


From 57e16cf010d64776ce44ad92d31e71ddab13640d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Sun, 14 Apr 2024 22:11:14 +0200
Subject: [PATCH 23/44] window/wayland: Constrain sporadic client resizes
 immediately

When a client resizes on its own, make sure the new size is passed
through the window constraints machinery directly, to trigger any
potential window management rule that might apply.

Fix a couple of tests to make use of this behavior by introducing a new
'wait_size' command that waits until a window has been resized to a
expected size.

This replaces the fix introduced in 0e736af301 ("window: Ensure
constraints after a Wayland client resize").

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3700>
---
 src/core/window.c                             |  3 --
 ...client-resize-respect-constraints.metatest |  4 +--
 src/tests/stacking/restore-size.metatest      |  3 +-
 src/tests/test-runner.c                       | 29 +++++++++++++++++++
 src/wayland/meta-window-wayland.c             |  6 +++-
 5 files changed, 37 insertions(+), 8 deletions(-)

diff --git a/src/core/window.c b/src/core/window.c
index 759e8a748..d0126b1b2 100644
--- a/src/core/window.c
+++ b/src/core/window.c
@@ -3997,9 +3997,6 @@ meta_window_move_resize_internal (MetaWindow          *window,
   meta_stack_update_window_tile_matches (window->display->stack,
                                          workspace_manager->active_workspace);
 
-  if (flags & META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE)
-    meta_window_queue (window, META_QUEUE_MOVE_RESIZE);
-
   /* This is a workaround for #1627. We still don't have any tests that can
    * reproduce this issue reliably and this is not a proper fix! */
   if (flags & META_MOVE_RESIZE_WAYLAND_FINISH_MOVE_RESIZE &&
diff --git a/src/tests/stacking/client-resize-respect-constraints.metatest b/src/tests/stacking/client-resize-respect-constraints.metatest
index 10789395f..1a66dc831 100644
--- a/src/tests/stacking/client-resize-respect-constraints.metatest
+++ b/src/tests/stacking/client-resize-respect-constraints.metatest
@@ -19,7 +19,7 @@ move w/1 300 200
 assert_position w/1 300 200
 
 resize w/1 600 500
-wait_reconfigure
+wait_size w/1 600 500
 assert_position w/1 200 100
 
 destroy w/1
@@ -38,7 +38,7 @@ move x/1 300 200
 assert_position x/1 300 200
 
 resize x/1 600 500
-wait_reconfigure
+wait_size x/1 600 500
 assert_position x/1 200 100
 
 destroy x/1
diff --git a/src/tests/stacking/restore-size.metatest b/src/tests/stacking/restore-size.metatest
index 198cc7a55..f5942a97f 100644
--- a/src/tests/stacking/restore-size.metatest
+++ b/src/tests/stacking/restore-size.metatest
@@ -18,8 +18,7 @@ wait
 assert_size x/1 500 400
 
 resize x/1 300 200
-wait_reconfigure
-assert_size x/1 300 200
+wait_size x/1 300 200
 maximize x/1
 wait_reconfigure
 unmaximize x/1
diff --git a/src/tests/test-runner.c b/src/tests/test-runner.c
index 42871656d..516160765 100644
--- a/src/tests/test-runner.c
+++ b/src/tests/test-runner.c
@@ -840,6 +840,35 @@ test_case_do (TestCase    *test,
       if (!test_case_wait (test, error))
         return FALSE;
     }
+  else if (strcmp (argv[0], "wait_size") == 0)
+    {
+      MetaTestClient *client;
+      const char *window_id;
+      MetaWindow *window;
+      int width, height;
+
+      if (argc != 4)
+        BAD_COMMAND("usage: %s <client-id>/<window-id> <width> <height>", argv[0]);
+
+      if (!test_case_parse_window_id (test, argv[1], &client, &window_id, error))
+        return FALSE;
+
+      window = meta_test_client_find_window (client, window_id, error);
+
+      width = atoi (argv[2]);
+      height = atoi (argv[3]);
+
+      while (TRUE)
+        {
+          MtkRectangle rect;
+
+          meta_window_get_frame_rect (window, &rect);
+          if (rect.width == width && rect.height == height)
+            break;
+
+          g_main_context_iteration (NULL, TRUE);
+        }
+    }
   else if (strcmp (argv[0], "dispatch") == 0)
     {
       if (argc != 1)
diff --git a/src/wayland/meta-window-wayland.c b/src/wayland/meta-window-wayland.c
index 354183106..bd3e40b91 100644
--- a/src/wayland/meta-window-wayland.c
+++ b/src/wayland/meta-window-wayland.c
@@ -1253,8 +1253,12 @@ meta_window_wayland_finish_move_resize (MetaWindow              *window,
   if (rect.width != window->rect.width || rect.height != window->rect.height)
     {
       flags |= META_MOVE_RESIZE_RESIZE_ACTION;
+
       if (is_client_resize)
-        flags |= META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE;
+        {
+          flags |= META_MOVE_RESIZE_WAYLAND_CLIENT_RESIZE;
+          flags |= META_MOVE_RESIZE_CONSTRAIN;
+        }
     }
 
   g_clear_pointer (&wl_window->last_acked_configuration,
-- 
2.45.0


From 8c39a2545933af70401550b601d225ae7ebe2acc Mon Sep 17 00:00:00 2001
From: Keyu Tao <me@taoky.moe>
Date: Tue, 30 Apr 2024 16:34:29 +0800
Subject: [PATCH 24/44] keybindings: Add refcounting to fix use-after-free for
 key handlers

Two new fields: ref_count and removed, are added to MetaKeyHandler, and
it would be freed only if the ref count has reached 0. When handler is
removed from key_handlers GHashTable, key_handler_destroy() would mark
removed as TRUE, and do an unref. handler->removed is checked in
get_keybinding, and binding with handler removed would not be used.

Also in MetaKeyBinding, it now has the ownership of the name field, to
avoid it being freed before logging. Create or copy a binding would
do a ref inc for handler, and free one would unref handler.

Fixes https://gitlab.gnome.org/GNOME/gnome-shell/-/issues/1870.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3711>
---
 src/core/keybindings-private.h |  4 ++-
 src/core/keybindings.c         | 58 ++++++++++++++++++++++++++--------
 2 files changed, 48 insertions(+), 14 deletions(-)

diff --git a/src/core/keybindings-private.h b/src/core/keybindings-private.h
index 0a05dd577..81ee7a32a 100644
--- a/src/core/keybindings-private.h
+++ b/src/core/keybindings-private.h
@@ -35,6 +35,7 @@
 typedef struct _MetaKeyHandler MetaKeyHandler;
 struct _MetaKeyHandler
 {
+  grefcount ref_count;
   char *name;
   MetaKeyHandlerFunc func;
   MetaKeyHandlerFunc default_func;
@@ -42,6 +43,7 @@ struct _MetaKeyHandler
   MetaKeyBindingFlags flags;
   gpointer user_data;
   GDestroyNotify user_data_free_func;
+  gboolean removed;
 };
 
 typedef struct _MetaResolvedKeyCombo {
@@ -65,7 +67,7 @@ struct _MetaKeyCombo
 
 struct _MetaKeyBinding
 {
-  const char *name;
+  char *name;
   MetaKeyCombo combo;
   MetaResolvedKeyCombo resolved_combo;
   gint flags;
diff --git a/src/core/keybindings.c b/src/core/keybindings.c
index 74e584889..c0e9de8b5 100644
--- a/src/core/keybindings.c
+++ b/src/core/keybindings.c
@@ -74,6 +74,9 @@
                            CLUTTER_BUTTON4_MASK |       \
                            CLUTTER_BUTTON5_MASK)
 
+static MetaKeyHandler * meta_key_handler_ref (MetaKeyHandler *handler);
+static void meta_key_handler_unref (MetaKeyHandler *handler);
+
 static void
 resolved_key_combo_reset (MetaResolvedKeyCombo *resolved_combo)
 {
@@ -120,7 +123,9 @@ resolved_key_combo_intersect (MetaResolvedKeyCombo *a,
 static void
 meta_key_binding_free (MetaKeyBinding *binding)
 {
+  g_free (binding->name);
   resolved_key_combo_reset (&binding->resolved_combo);
+  meta_key_handler_unref (binding->handler);
   g_free (binding);
 }
 
@@ -130,6 +135,8 @@ meta_key_binding_copy (MetaKeyBinding *binding)
   MetaKeyBinding *clone = g_memdup2 (binding, sizeof (MetaKeyBinding));
   resolved_key_combo_copy (&binding->resolved_combo,
                            &clone->resolved_combo);
+  clone->name = g_strdup (binding->name);
+  clone->handler = meta_key_handler_ref (binding->handler);
   return clone;
 }
 
@@ -181,13 +188,30 @@ static GHashTable *external_grabs;
 
 #define HANDLER(name) g_hash_table_lookup (key_handlers, (name))
 
+static MetaKeyHandler *
+meta_key_handler_ref (MetaKeyHandler *handler)
+{
+  g_ref_count_inc (&handler->ref_count);
+  return handler;
+}
+
 static void
-key_handler_free (MetaKeyHandler *handler)
+meta_key_handler_unref (MetaKeyHandler *handler)
 {
-  g_free (handler->name);
-  if (handler->user_data_free_func && handler->user_data)
-    handler->user_data_free_func (handler->user_data);
-  g_free (handler);
+  if (g_ref_count_dec (&handler->ref_count))
+    {
+      g_free (handler->name);
+      if (handler->user_data_free_func && handler->user_data)
+        handler->user_data_free_func (handler->user_data);
+      g_free (handler);
+    }
+}
+
+static void
+meta_key_handler_destroy (MetaKeyHandler *handler)
+{
+  handler->removed = TRUE;
+  meta_key_handler_unref (handler);
 }
 
 typedef struct _MetaKeyGrab MetaKeyGrab;
@@ -782,7 +806,7 @@ reload_combos (MetaKeyBindingManager *keys)
 }
 
 static void
-rebuild_binding_table (MetaKeyBindingManager *keys,
+rebuild_binding_table (MetaKeyBindingManager  *keys,
                        GList                  *prefs,
                        GList                  *grabs)
 {
@@ -806,8 +830,8 @@ rebuild_binding_table (MetaKeyBindingManager *keys,
               MetaKeyHandler *handler = HANDLER (pref->name);
 
               b = g_new0 (MetaKeyBinding, 1);
-              b->name = pref->name;
-              b->handler = handler;
+              b->name = g_strdup (pref->name);
+              b->handler = meta_key_handler_ref (handler);
               b->flags = handler->flags;
               b->combo = *combo;
 
@@ -829,8 +853,8 @@ rebuild_binding_table (MetaKeyBindingManager *keys,
           MetaKeyHandler *handler = HANDLER ("external-grab");
 
           b = g_new0 (MetaKeyBinding, 1);
-          b->name = grab->name;
-          b->handler = handler;
+          b->name = g_strdup (grab->name);
+          b->handler = meta_key_handler_ref (handler);
           b->flags = grab->flags;
           b->combo = grab->combo;
 
@@ -923,6 +947,9 @@ get_keybinding (MetaKeyBindingManager *keys,
       binding = g_hash_table_lookup (keys->key_bindings_index,
                                      GINT_TO_POINTER (key));
 
+      if (binding && binding->handler->removed)
+        binding = NULL;
+
       if (binding != NULL)
         break;
     }
@@ -961,6 +988,7 @@ add_keybinding_internal (MetaDisplay          *display,
   handler->flags = flags;
   handler->user_data = user_data;
   handler->user_data_free_func = free_data;
+  g_ref_count_init (&handler->ref_count);
 
   g_hash_table_insert (key_handlers, g_strdup (name), handler);
 
@@ -1719,8 +1747,8 @@ meta_display_grab_accelerator (MetaDisplay         *display,
   g_hash_table_insert (external_grabs, grab->name, grab);
 
   binding = g_new0 (MetaKeyBinding, 1);
-  binding->name = grab->name;
-  binding->handler = HANDLER ("external-grab");
+  binding->name = g_strdup (grab->name);
+  binding->handler = meta_key_handler_ref (HANDLER ("external-grab"));
   binding->combo = combo;
   binding->resolved_combo = resolved_combo;
   binding->flags = flags;
@@ -3206,23 +3234,26 @@ meta_display_init_keys (MetaDisplay *display)
   reload_modmap (keys);
 
   key_handlers = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
-                                        (GDestroyNotify) key_handler_free);
+                                        (GDestroyNotify) meta_key_handler_destroy);
 
   handler = g_new0 (MetaKeyHandler, 1);
   handler->name = g_strdup ("overlay-key");
   handler->flags = META_KEY_BINDING_BUILTIN | META_KEY_BINDING_NO_AUTO_GRAB;
+  g_ref_count_init (&handler->ref_count);
 
   g_hash_table_insert (key_handlers, g_strdup (handler->name), handler);
 
   handler = g_new0 (MetaKeyHandler, 1);
   handler->name = g_strdup ("locate-pointer-key");
   handler->flags = META_KEY_BINDING_BUILTIN | META_KEY_BINDING_NO_AUTO_GRAB;
+  g_ref_count_init (&handler->ref_count);
 
   g_hash_table_insert (key_handlers, g_strdup (handler->name), handler);
 
   handler = g_new0 (MetaKeyHandler, 1);
   handler->name = g_strdup ("iso-next-group");
   handler->flags = META_KEY_BINDING_BUILTIN;
+  g_ref_count_init (&handler->ref_count);
 
   g_hash_table_insert (key_handlers, g_strdup (handler->name), handler);
 
@@ -3230,6 +3261,7 @@ meta_display_init_keys (MetaDisplay *display)
   handler->name = g_strdup ("external-grab");
   handler->func = handle_external_grab;
   handler->default_func = handle_external_grab;
+  g_ref_count_init (&handler->ref_count);
 
   g_hash_table_insert (key_handlers, g_strdup (handler->name), handler);
 
-- 
2.45.0


From 22f67d107dd4fbc605763be4fd7bf42e2a772aba Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Fri, 26 Apr 2024 23:01:38 +0200
Subject: [PATCH 25/44] tests: Add test case for keybinding remove race

When a key binding is removed, and a trigger key sequence is dispatched
before the idle callback that resolves and updates the actual binding,
we should handle that gracefully.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/3711>
---
 src/tests/keybindings.c                     | 146 ++++++++++++++++++++
 src/tests/meson.build                       |  10 ++
 src/tests/org.gnome.mutter.test.gschema.xml |  14 ++
 3 files changed, 170 insertions(+)
 create mode 100644 src/tests/keybindings.c
 create mode 100644 src/tests/org.gnome.mutter.test.gschema.xml

diff --git a/src/tests/keybindings.c b/src/tests/keybindings.c
new file mode 100644
index 000000000..64e48e06f
--- /dev/null
+++ b/src/tests/keybindings.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2024 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "config.h"
+
+#include <linux/input-event-codes.h>
+
+#include "backends/meta-backend-private.h"
+#include "meta/keybindings.h"
+#include "meta-test/meta-context-test.h"
+#include "tests/meta-test-utils.h"
+
+static MetaContext *test_context;
+
+static void
+test_handler (MetaDisplay           *display,
+              MetaWindow            *window,
+              const ClutterKeyEvent *event,
+              MetaKeyBinding        *binding,
+              gpointer               user_data)
+{
+  gboolean *triggered = user_data;
+
+  *triggered = TRUE;
+}
+
+static gboolean
+set_true_cb (gpointer user_data)
+{
+  gboolean *done = user_data;
+
+  *done = TRUE;
+
+  return G_SOURCE_REMOVE;
+}
+
+static void
+test_keybinding_remove_trigger (void)
+{
+  MetaDisplay *display = meta_context_get_display (test_context);
+  MetaBackend *backend = meta_context_get_backend (test_context);
+  ClutterSeat *seat;
+  g_autoptr (GSettings) settings = NULL;
+  g_autoptr (ClutterVirtualInputDevice) virtual_keyboard = NULL;
+  gboolean triggered = FALSE;
+  gboolean done = FALSE;
+
+  seat = meta_backend_get_default_seat (backend);
+  virtual_keyboard = clutter_seat_create_virtual_device (seat,
+                                                         CLUTTER_KEYBOARD_DEVICE);
+
+  settings = g_settings_new ("org.gnome.mutter.test");
+  meta_display_add_keybinding (display,
+                               "test-binding",
+                               settings,
+                               META_KEY_BINDING_NONE,
+                               test_handler,
+                               &triggered, NULL);
+
+  g_idle_add_full (G_PRIORITY_LOW,
+                   set_true_cb,
+                   &done,
+                   NULL);
+  while (!done)
+    g_main_context_iteration (NULL, TRUE);
+
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_LEFTMETA,
+                                           CLUTTER_KEY_STATE_PRESSED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_T,
+                                           CLUTTER_KEY_STATE_PRESSED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_T,
+                                           CLUTTER_KEY_STATE_RELEASED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_LEFTMETA,
+                                           CLUTTER_KEY_STATE_RELEASED);
+
+  while (!triggered)
+    g_main_context_iteration (NULL, TRUE);
+
+  meta_display_remove_keybinding (display, "test-binding");
+
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_LEFTMETA,
+                                           CLUTTER_KEY_STATE_PRESSED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_T,
+                                           CLUTTER_KEY_STATE_PRESSED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_T,
+                                           CLUTTER_KEY_STATE_RELEASED);
+  clutter_virtual_input_device_notify_key (virtual_keyboard,
+                                           g_get_monotonic_time (),
+                                           KEY_LEFTMETA,
+                                           CLUTTER_KEY_STATE_RELEASED);
+
+  meta_flush_input (test_context);
+  while (g_main_context_iteration (NULL, FALSE)) {}
+}
+
+static void
+init_tests (void)
+{
+  g_test_add_func ("/core/keybindings/remove-trigger", test_keybinding_remove_trigger);
+}
+
+int
+main (int    argc,
+      char **argv)
+{
+  g_autoptr (MetaContext) context = NULL;
+
+  context = meta_create_test_context (META_CONTEXT_TEST_TYPE_HEADLESS,
+                                      META_CONTEXT_TEST_FLAG_NO_X11);
+  g_assert (meta_context_configure (context, &argc, &argv, NULL));
+
+  test_context = context;
+  init_tests ();
+
+  return meta_context_test_run_tests (META_CONTEXT_TEST (context),
+                                      META_TEST_RUN_FLAG_NONE);
+}
diff --git a/src/tests/meson.build b/src/tests/meson.build
index bb630cbb9..18314c937 100644
--- a/src/tests/meson.build
+++ b/src/tests/meson.build
@@ -116,6 +116,10 @@ pkg.generate(libmutter_test,
   install_dir: pcdir,
 )
 
+gnome.compile_schemas(
+  depend_files: 'org.gnome.mutter.test.gschema.xml',
+)
+
 if have_cogl_tests
   subdir('cogl')
 endif
@@ -140,6 +144,7 @@ test_env_variables = {
   'G_TEST_BUILDDIR': mutter_builddir,
   'XDG_CONFIG_HOME': mutter_builddir / '.config',
   'MUTTER_TEST_PLUGIN_PATH': '@0@'.format(default_plugin.full_path()),
+  'GSETTINGS_SCHEMA_DIR': mutter_builddir / 'src' / 'tests',
 }
 
 foreach name, value: test_env_variables
@@ -292,6 +297,11 @@ test_cases += [
     'suite': 'unit',
     'sources': [ 'color-management-profile-conflict-test.c', ],
   },
+  {
+    'name': 'keybindings',
+    'suite': 'input',
+    'sources': [ 'keybindings.c' ],
+  },
 ]
 
 if have_native_tests
diff --git a/src/tests/org.gnome.mutter.test.gschema.xml b/src/tests/org.gnome.mutter.test.gschema.xml
new file mode 100644
index 000000000..85a4d7448
--- /dev/null
+++ b/src/tests/org.gnome.mutter.test.gschema.xml
@@ -0,0 +1,14 @@
+<schemalist>
+
+  <schema id="org.gnome.mutter.test" path="/org/gnome/mutter/test/">
+
+  <key name="test-binding" type="as">
+    <default>['&lt;Super&gt;t']</default>
+      <summary>Test</summary>
+      <description>
+	Test.
+      </description>
+    </key>
+
+  </schema>
+</schemalist>
-- 
2.45.0


From 81566e3e9c9cc4594c5f16159bd750b207b9185f Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 16 Jan 2024 16:41:39 +0100
Subject: [PATCH 26/44] monitor-config-manager: Use autoptr in more cases

---
 src/backends/meta-monitor-config-manager.c | 19 ++++++-------------
 1 file changed, 6 insertions(+), 13 deletions(-)

diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index 358b01f15..e8294a660 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -383,9 +383,9 @@ meta_monitor_config_manager_assign (MetaMonitorManager *manager,
                                     GPtrArray         **out_output_assignments,
                                     GError            **error)
 {
-  GPtrArray *crtc_assignments;
-  GPtrArray *output_assignments;
-  GArray *reserved_crtcs;
+  g_autoptr (GPtrArray) crtc_assignments = NULL;
+  g_autoptr (GPtrArray) output_assignments = NULL;
+  g_autoptr (GArray) reserved_crtcs = NULL;
   GList *l;
 
   crtc_assignments =
@@ -432,18 +432,11 @@ meta_monitor_config_manager_assign (MetaMonitorManager *manager,
                                          config, logical_monitor_config,
                                          crtc_assignments, output_assignments,
                                          reserved_crtcs, error))
-        {
-          g_ptr_array_free (crtc_assignments, TRUE);
-          g_ptr_array_free (output_assignments, TRUE);
-          g_array_free (reserved_crtcs, TRUE);
-          return FALSE;
-        }
+        return FALSE;
     }
 
-  g_array_free (reserved_crtcs, TRUE);
-
-  *out_crtc_assignments = crtc_assignments;
-  *out_output_assignments = output_assignments;
+  *out_crtc_assignments = g_steal_pointer (&crtc_assignments);
+  *out_output_assignments = g_steal_pointer (&output_assignments);
 
   return TRUE;
 }
-- 
2.45.0


From 8c9b2d5766739da8e1090996bdab8a7f5f697729 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 7 Jul 2021 16:54:16 +0200
Subject: [PATCH 27/44] kms/connector: Add 'for-lease' getter

This is intended to be used to filter out what connectors will be
available for lease, i.e. non-desktop ones.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/backends/native/meta-gpu-kms.c       | 7 ++++---
 src/backends/native/meta-kms-connector.c | 6 ++++++
 src/backends/native/meta-kms-connector.h | 2 ++
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/src/backends/native/meta-gpu-kms.c b/src/backends/native/meta-gpu-kms.c
index 3e0ad99c5..3b4356ca6 100644
--- a/src/backends/native/meta-gpu-kms.c
+++ b/src/backends/native/meta-gpu-kms.c
@@ -348,13 +348,14 @@ init_outputs (MetaGpuKms *gpu_kms)
   for (l = meta_kms_device_get_connectors (gpu_kms->kms_device); l; l = l->next)
     {
       MetaKmsConnector *kms_connector = l->data;
-      const MetaKmsConnectorState *connector_state;
       MetaOutputKms *output_kms;
       MetaOutput *old_output;
       GError *error = NULL;
 
-      connector_state = meta_kms_connector_get_current_state (kms_connector);
-      if (!connector_state || connector_state->non_desktop)
+      if (!meta_kms_connector_get_current_state (kms_connector))
+        continue;
+
+      if (meta_kms_connector_is_for_lease (kms_connector))
         continue;
 
       old_output =
diff --git a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
index d47d9c835..0bf3a84d9 100644
--- a/src/backends/native/meta-kms-connector.c
+++ b/src/backends/native/meta-kms-connector.c
@@ -164,6 +164,12 @@ meta_kms_connector_get_current_state (MetaKmsConnector *connector)
   return connector->current_state;
 }
 
+gboolean
+meta_kms_connector_is_for_lease (MetaKmsConnector *connector)
+{
+  return connector->current_state && connector->current_state->non_desktop;
+}
+
 static gboolean
 has_privacy_screen_software_toggle (MetaKmsConnector *connector)
 {
diff --git a/src/backends/native/meta-kms-connector.h b/src/backends/native/meta-kms-connector.h
index cb71b4987..c10326d2a 100644
--- a/src/backends/native/meta-kms-connector.h
+++ b/src/backends/native/meta-kms-connector.h
@@ -101,3 +101,5 @@ MetaKmsMode * meta_kms_connector_get_preferred_mode (MetaKmsConnector *connector
 
 META_EXPORT_TEST
 const MetaKmsConnectorState * meta_kms_connector_get_current_state (MetaKmsConnector *connector);
+
+gboolean meta_kms_connector_is_for_lease (MetaKmsConnector *connector);
-- 
2.45.0


From f06b97c14d7b3ea674797651e96e6166e8250f30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Exp=C3=B3sito?= <jexposit@redhat.com>
Date: Thu, 9 May 2024 11:06:38 +0200
Subject: [PATCH 28/44] kms/connector: Allow to force connectors for lease

Add an environment variable (MUTTER_DEBUG_LEASE_CONNECTORS) that allows
set a ":" separated list of connector names as available for lease.

The names of the connectors can be found in "/sys/class/drm".

To illustrate it with an example, the names of the connectors and its
status can be fetched with this command:

  $ for p in /sys/class/drm/*/status; do con=${p%/status}; echo -n "${con#*/card?-}: "; cat $p; done
  DP-1: disconnected
  DP-2: disconnected
  DP-3: disconnected
  DP-4: disconnected
  DP-5: connected
  DP-6: connected
  DP-7: disconnected
  eDP-1: connected
  HDMI-A-1: disconnected

And, to set "DP-5" and "DP-6" available for lease, the environment
variable can be set like:

  MUTTER_DEBUG_LEASE_CONNECTORS=DP-5:DP-6
---
 src/backends/native/meta-kms-connector.c | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/backends/native/meta-kms-connector.c b/src/backends/native/meta-kms-connector.c
index 0bf3a84d9..be5f36106 100644
--- a/src/backends/native/meta-kms-connector.c
+++ b/src/backends/native/meta-kms-connector.c
@@ -167,7 +167,25 @@ meta_kms_connector_get_current_state (MetaKmsConnector *connector)
 gboolean
 meta_kms_connector_is_for_lease (MetaKmsConnector *connector)
 {
-  return connector->current_state && connector->current_state->non_desktop;
+  const char *lease_connectors_str;
+
+  if (!connector->current_state)
+    return FALSE;
+
+  lease_connectors_str = getenv ("MUTTER_DEBUG_LEASE_CONNECTORS");
+  if (lease_connectors_str && *lease_connectors_str != '\0')
+    {
+      int n;
+      g_auto (GStrv) names = g_strsplit (lease_connectors_str, ":", -1);
+
+      for (n = 0; n < g_strv_length (names); n++)
+        {
+          if (g_str_equal (meta_kms_connector_get_name (connector), names[n]))
+            return TRUE;
+        }
+    }
+
+  return connector->current_state->non_desktop;
 }
 
 static gboolean
-- 
2.45.0


From 193a00cd32c25617a5dd4f9d6e41976b2dd1d18f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 7 Jul 2021 16:54:53 +0200
Subject: [PATCH 29/44] kms: Add 'device-added' signal

This signals when there was a mode setting device added.
---
 src/backends/native/meta-kms.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/backends/native/meta-kms.c b/src/backends/native/meta-kms.c
index 795008b21..868d30e4a 100644
--- a/src/backends/native/meta-kms.c
+++ b/src/backends/native/meta-kms.c
@@ -34,6 +34,7 @@
 enum
 {
   RESOURCES_CHANGED,
+  DEVICE_ADDED,
 
   N_SIGNALS
 };
@@ -336,6 +337,8 @@ meta_kms_create_device (MetaKms            *kms,
 
   kms->devices = g_list_append (kms->devices, device);
 
+  g_signal_emit (kms, signals[DEVICE_ADDED], 0, device);
+
   return device;
 }
 
@@ -447,6 +450,15 @@ meta_kms_class_init (MetaKmsClass *klass)
                   G_TYPE_NONE, 1,
                   META_TYPE_KMS_RESOURCE_CHANGES);
 
+  signals[DEVICE_ADDED] =
+    g_signal_new ("device-added",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  META_TYPE_KMS_DEVICE);
+
   meta_thread_class_register_impl_type (thread_class, META_TYPE_KMS_IMPL);
 }
 
-- 
2.45.0


From d9695afd747dbe311810d4e554a6309ddf2ab975 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Jan 2022 17:24:12 +0100
Subject: [PATCH 30/44] monitor-config-manager: Consider leased CRTCs assigned

With leasing, we will give another client control over connectors but
they also need a CRTC to drive them. Those CRTCs won't be available to
the desktop/monitor-manager.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/backends/meta-crtc.c                   | 11 +++++++++++
 src/backends/meta-crtc.h                   |  4 ++++
 src/backends/meta-monitor-config-manager.c |  3 +++
 src/backends/native/meta-crtc-kms.c        | 10 ++++++++++
 src/backends/native/meta-kms-crtc.c        |  8 ++++++++
 src/backends/native/meta-kms-crtc.h        |  2 ++
 6 files changed, 38 insertions(+)

diff --git a/src/backends/meta-crtc.c b/src/backends/meta-crtc.c
index 646a508b9..bca008ea9 100644
--- a/src/backends/meta-crtc.c
+++ b/src/backends/meta-crtc.c
@@ -470,3 +470,14 @@ meta_crtc_config_new (graphene_rect_t      *layout,
 
   return config;
 }
+
+gboolean
+meta_crtc_is_leased (MetaCrtc *crtc)
+{
+  MetaCrtcClass *klass = META_CRTC_GET_CLASS (crtc);
+
+  if (klass->is_leased)
+    return klass->is_leased (crtc);
+  else
+    return FALSE;
+}
diff --git a/src/backends/meta-crtc.h b/src/backends/meta-crtc.h
index 0b1eb8b67..68ff58ea8 100644
--- a/src/backends/meta-crtc.h
+++ b/src/backends/meta-crtc.h
@@ -55,6 +55,8 @@ struct _MetaCrtcClass
   void (* set_config) (MetaCrtc             *crtc,
                        const MetaCrtcConfig *config,
                        gpointer              backend_private);
+
+  gboolean (* is_leased) (MetaCrtc *crtc);
 };
 
 META_EXPORT_TEST
@@ -132,4 +134,6 @@ MetaCrtcConfig * meta_crtc_config_new (graphene_rect_t      *layout,
                                        MetaCrtcMode         *mode,
                                        MetaMonitorTransform  transform);
 
+gboolean meta_crtc_is_leased (MetaCrtc *crtc);
+
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (MetaGammaLut, meta_gamma_lut_free)
diff --git a/src/backends/meta-monitor-config-manager.c b/src/backends/meta-monitor-config-manager.c
index e8294a660..efc48d45e 100644
--- a/src/backends/meta-monitor-config-manager.c
+++ b/src/backends/meta-monitor-config-manager.c
@@ -99,6 +99,9 @@ is_crtc_assigned (MetaCrtc  *crtc,
 {
   unsigned int i;
 
+  if (meta_crtc_is_leased (crtc))
+    return TRUE;
+
   for (i = 0; i < crtc_assignments->len; i++)
     {
       MetaCrtcAssignment *assigned_crtc_assignment =
diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 3498f922a..1b426d76d 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -326,6 +326,15 @@ meta_crtc_kms_set_config (MetaCrtc             *crtc,
   crtc_kms->assigned_cursor_plane = kms_assignment->cursor_plane;
 }
 
+static gboolean
+meta_crtc_kms_is_leased (MetaCrtc *crtc)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+
+  return meta_kms_crtc_is_leased (kms_crtc);
+}
+
 static gboolean
 meta_crtc_kms_is_transform_handled (MetaCrtcNative       *crtc_native,
                                     MetaMonitorTransform  transform)
@@ -476,6 +485,7 @@ meta_crtc_kms_class_init (MetaCrtcKmsClass *klass)
   crtc_class->set_gamma_lut = meta_crtc_kms_set_gamma_lut;
   crtc_class->assign_extra = meta_crtc_kms_assign_extra;
   crtc_class->set_config = meta_crtc_kms_set_config;
+  crtc_class->is_leased = meta_crtc_kms_is_leased;
 
   crtc_native_class->is_transform_handled = meta_crtc_kms_is_transform_handled;
   crtc_native_class->is_hw_cursor_supported = meta_crtc_kms_is_hw_cursor_supported;
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index a0872089a..6ca1c08d3 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -50,6 +50,8 @@ struct _MetaKmsCrtc
   MetaKmsCrtcState current_state;
 
   MetaKmsCrtcPropTable prop_table;
+
+  gboolean is_leased;
 };
 
 G_DEFINE_TYPE (MetaKmsCrtc, meta_kms_crtc, G_TYPE_OBJECT)
@@ -107,6 +109,12 @@ meta_kms_crtc_is_active (MetaKmsCrtc *crtc)
   return crtc->current_state.is_active;
 }
 
+gboolean
+meta_kms_crtc_is_leased (MetaKmsCrtc *crtc)
+{
+  return crtc->is_leased;
+}
+
 static void
 read_crtc_gamma (MetaKmsCrtc       *crtc,
                  MetaKmsCrtcState  *crtc_state,
diff --git a/src/backends/native/meta-kms-crtc.h b/src/backends/native/meta-kms-crtc.h
index 580ee9a89..af6538cd3 100644
--- a/src/backends/native/meta-kms-crtc.h
+++ b/src/backends/native/meta-kms-crtc.h
@@ -65,3 +65,5 @@ int meta_kms_crtc_get_idx (MetaKmsCrtc *crtc);
 
 META_EXPORT_TEST
 gboolean meta_kms_crtc_is_active (MetaKmsCrtc *crtc);
+
+gboolean meta_kms_crtc_is_leased (MetaKmsCrtc *crtc);
-- 
2.45.0


From add6b65ac08d2dab65b093b6c19e7316b7bccac2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Mon, 3 Jan 2022 17:24:12 +0100
Subject: [PATCH 31/44] kms-device-impl: Implement leasing, revoking and
 listing leases

The lease_objects function takes connectors, CRTCs and planes which are
turned into a drm lease. The resulting lease can be revoked with
revoke_lease. With list_lessees the currently active leases can be
queried.

Co-authored-by: Sebastian Wick <sebastian.wick@redhat.com>
---
 src/backends/native/meta-kms-device.c      | 139 ++++++++++++
 src/backends/native/meta-kms-device.h      |  17 ++
 src/backends/native/meta-kms-impl-device.c | 238 ++++++++++++++++-----
 src/backends/native/meta-kms-impl-device.h |  17 ++
 4 files changed, 355 insertions(+), 56 deletions(-)

diff --git a/src/backends/native/meta-kms-device.c b/src/backends/native/meta-kms-device.c
index 127a05de7..b3fcc71bd 100644
--- a/src/backends/native/meta-kms-device.c
+++ b/src/backends/native/meta-kms-device.c
@@ -423,6 +423,145 @@ meta_kms_device_handle_flush (MetaKmsDevice *device,
   return needs_flush;
 }
 
+typedef struct
+{
+  MetaKmsDevice *device;
+  GList *connectors;
+  GList *crtcs;
+  GList *planes;
+
+  int fd;
+  uint32_t lessee_id;
+} LeaseRequestData;
+
+static gpointer
+lease_objects_in_impl (MetaThreadImpl  *thread_impl,
+                       gpointer         user_data,
+                       GError         **error)
+{
+  LeaseRequestData *data = user_data;
+  MetaKmsImplDevice *impl_device =
+    meta_kms_device_get_impl_device (data->device);
+  uint32_t lessee_id;
+  int fd;
+
+  if (!meta_kms_impl_device_lease_objects (impl_device,
+                                           data->connectors,
+                                           data->crtcs,
+                                           data->planes,
+                                           &fd,
+                                           &lessee_id,
+                                           error))
+    return GINT_TO_POINTER (FALSE);
+
+  data->fd = fd;
+  data->lessee_id = lessee_id;
+
+  return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_lease_objects (MetaKmsDevice  *device,
+                               GList          *connectors,
+                               GList          *crtcs,
+                               GList          *planes,
+                               int            *out_fd,
+                               uint32_t       *out_lessee_id,
+                               GError        **error)
+{
+  LeaseRequestData data = {};
+
+  data.device = device;
+  data.connectors = connectors;
+  data.crtcs = crtcs;
+  data.planes = planes;
+
+  if (!meta_kms_run_impl_task_sync (device->kms, lease_objects_in_impl, &data,
+                                    error))
+    return FALSE;
+
+  *out_fd = data.fd;
+  *out_lessee_id = data.lessee_id;
+  return TRUE;
+}
+
+typedef struct
+{
+  MetaKmsDevice *device;
+  uint32_t lessee_id;
+} RevokeLeaseData;
+
+static gpointer
+revoke_lease_in_impl (MetaThreadImpl  *thread_impl,
+                      gpointer         user_data,
+                      GError         **error)
+{
+  LeaseRequestData *data = user_data;
+  MetaKmsImplDevice *impl_device =
+    meta_kms_device_get_impl_device (data->device);
+
+  if (!meta_kms_impl_device_revoke_lease (impl_device, data->lessee_id, error))
+    return GINT_TO_POINTER (FALSE);
+  else
+    return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_revoke_lease (MetaKmsDevice  *device,
+                              uint32_t        lessee_id,
+                              GError        **error)
+{
+  LeaseRequestData data = {};
+
+  data.device = device;
+  data.lessee_id = lessee_id;
+
+  return !!meta_kms_run_impl_task_sync (device->kms, revoke_lease_in_impl, &data,
+                                        error);
+}
+
+typedef struct
+{
+  MetaKmsDevice *device;
+  uint32_t **out_lessee_ids;
+  int *out_num_lessee_ids;
+} ListLesseesData;
+
+static gpointer
+list_lessees_in_impl (MetaThreadImpl  *thread_impl,
+                      gpointer         user_data,
+                      GError         **error)
+{
+  ListLesseesData *data = user_data;
+  MetaKmsImplDevice *impl_device = meta_kms_device_get_impl_device (data->device);
+
+  if (!meta_kms_impl_device_list_lessees (impl_device,
+                                          data->out_lessee_ids,
+                                          data->out_num_lessee_ids,
+                                          error))
+    return GINT_TO_POINTER (FALSE);
+  else
+    return GINT_TO_POINTER (TRUE);
+}
+
+gboolean
+meta_kms_device_list_lessees (MetaKmsDevice  *device,
+                              uint32_t      **out_lessee_ids,
+                              int            *out_num_lessee_ids,
+                              GError        **error)
+{
+  ListLesseesData data = {};
+
+  data.device = device;
+  data.out_lessee_ids = out_lessee_ids;
+  data.out_num_lessee_ids = out_num_lessee_ids;
+
+  return !!meta_kms_run_impl_task_sync (device->kms,
+                                        list_lessees_in_impl,
+                                        &data,
+                                        error);
+}
+
 typedef struct _CreateImplDeviceData
 {
   MetaKmsDevice *device;
diff --git a/src/backends/native/meta-kms-device.h b/src/backends/native/meta-kms-device.h
index 00dafb16c..0b39f7df5 100644
--- a/src/backends/native/meta-kms-device.h
+++ b/src/backends/native/meta-kms-device.h
@@ -86,6 +86,23 @@ gboolean meta_kms_device_handle_flush (MetaKmsDevice *device,
 META_EXPORT_TEST
 void meta_kms_device_disable (MetaKmsDevice *device);
 
+gboolean meta_kms_device_lease_objects (MetaKmsDevice  *device,
+                                        GList          *connectors,
+                                        GList          *crtcs,
+                                        GList          *planes,
+                                        int            *out_fd,
+                                        uint32_t       *out_lessee_id,
+                                        GError        **error);
+
+gboolean meta_kms_device_revoke_lease (MetaKmsDevice  *device,
+                                       uint32_t        lessee_id,
+                                       GError        **error);
+
+gboolean meta_kms_device_list_lessees (MetaKmsDevice  *device,
+                                       uint32_t      **out_lessee_ids,
+                                       int            *out_num_lessee_ids,
+                                       GError        **error);
+
 MetaKmsDevice * meta_kms_device_new (MetaKms            *kms,
                                      const char         *path,
                                      MetaKmsDeviceFlag   flags,
diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index 980487482..d6ef26729 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -263,6 +263,188 @@ meta_kms_impl_device_get_path (MetaKmsImplDevice *impl_device)
   return priv->path;
 }
 
+static MetaDeviceFile *
+meta_kms_impl_device_open_device_file (MetaKmsImplDevice  *impl_device,
+                                       const char         *path,
+                                       GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  MetaKmsImplDeviceClass *klass = META_KMS_IMPL_DEVICE_GET_CLASS (impl_device);
+
+  return klass->open_device_file (impl_device, priv->path, error);
+}
+
+static gpointer
+kms_event_dispatch_in_impl (MetaThreadImpl  *impl,
+                            gpointer         user_data,
+                            GError         **error)
+{
+  MetaKmsImplDevice *impl_device = user_data;
+  gboolean ret;
+
+  ret = meta_kms_impl_device_dispatch (impl_device, error);
+  return GINT_TO_POINTER (ret);
+}
+
+static gboolean
+ensure_device_file (MetaKmsImplDevice  *impl_device,
+                    GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  MetaDeviceFile *device_file;
+
+  if (priv->device_file)
+    return TRUE;
+
+  device_file = meta_kms_impl_device_open_device_file (impl_device,
+                                                       priv->path,
+                                                       error);
+  if (!device_file)
+    return FALSE;
+
+  priv->device_file = device_file;
+
+  if (!(priv->flags & META_KMS_DEVICE_FLAG_NO_MODE_SETTING))
+    {
+      priv->fd_source =
+        meta_thread_impl_register_fd (META_THREAD_IMPL (priv->impl),
+                                      meta_device_file_get_fd (device_file),
+                                      kms_event_dispatch_in_impl,
+                                      impl_device);
+      g_source_set_priority (priv->fd_source, G_PRIORITY_HIGH);
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_lease_objects (MetaKmsImplDevice  *impl_device,
+                                    GList              *connectors,
+                                    GList              *crtcs,
+                                    GList              *planes,
+                                    int                *out_fd,
+                                    uint32_t           *out_lessee_id,
+                                    GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  uint32_t *object_ids;
+  int n_object_ids;
+  GList *l;
+  int retval;
+  uint32_t lessee_id;
+  int i = 0;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  if (!ensure_device_file (impl_device, error))
+    return FALSE;
+
+  meta_kms_impl_device_hold_fd (impl_device);
+
+  n_object_ids = (g_list_length (connectors) +
+                  g_list_length (crtcs) +
+                  g_list_length (planes));
+  object_ids = g_alloca (sizeof (uint32_t) * n_object_ids);
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+
+      object_ids[i++] = meta_kms_connector_get_id (connector);
+    }
+
+  for (l = crtcs; l; l = l->next)
+    {
+      MetaKmsCrtc *crtc = l->data;
+
+      object_ids[i++] = meta_kms_crtc_get_id (crtc);
+    }
+
+  for (l = planes; l; l = l->next)
+    {
+      MetaKmsPlane *plane = l->data;
+
+      object_ids[i++] = meta_kms_plane_get_id (plane);
+    }
+
+  retval = drmModeCreateLease (meta_kms_impl_device_get_fd (impl_device),
+                               object_ids, n_object_ids, 0,
+                               &lessee_id);
+
+  if (retval < 0)
+    {
+      meta_kms_impl_device_unhold_fd (impl_device);
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-retval),
+                   "Failed to create lease: %s", g_strerror (-retval));
+      return FALSE;
+    }
+
+  *out_fd = retval;
+  *out_lessee_id = lessee_id;
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_revoke_lease (MetaKmsImplDevice  *impl_device,
+                                   uint32_t            lessee_id,
+                                   GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  int retval;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  retval = drmModeRevokeLease (meta_kms_impl_device_get_fd (impl_device),
+                               lessee_id);
+  meta_kms_impl_device_unhold_fd (impl_device);
+
+  if (retval != 0)
+    {
+      g_set_error (error, G_IO_ERROR, g_io_error_from_errno (-retval),
+                   "Failed to revoke lease: %s", g_strerror (-retval));
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_kms_impl_device_list_lessees (MetaKmsImplDevice  *impl_device,
+                                   uint32_t          **out_lessee_ids,
+                                   int                *out_num_lessee_ids,
+                                   GError            **error)
+{
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  drmModeLesseeListRes *list;
+  int i;
+  uint32_t *lessee_ids;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  list = drmModeListLessees (meta_kms_impl_device_get_fd (impl_device));
+
+  if (!list)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to list lessees");
+      return FALSE;
+    }
+
+  lessee_ids = g_malloc0 (list->count * sizeof (uint32_t));
+  for (i = 0; i < list->count; i++)
+    lessee_ids[i] = list->lessees[i];
+
+  *out_lessee_ids = lessee_ids;
+  *out_num_lessee_ids = list->count;
+  return TRUE;
+}
+
 gboolean
 meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
                                GError            **error)
@@ -313,18 +495,6 @@ meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
   return TRUE;
 }
 
-static gpointer
-kms_event_dispatch_in_impl (MetaThreadImpl  *impl,
-                            gpointer         user_data,
-                            GError         **error)
-{
-  MetaKmsImplDevice *impl_device = user_data;
-  gboolean ret;
-
-  ret = meta_kms_impl_device_dispatch (impl_device, error);
-  return GINT_TO_POINTER (ret);
-}
-
 drmModePropertyPtr
 meta_kms_impl_device_find_property (MetaKmsImplDevice       *impl_device,
                                     drmModeObjectProperties *props,
@@ -889,50 +1059,6 @@ init_fallback_modes (MetaKmsImplDevice *impl_device)
   priv->fallback_modes = g_list_reverse (modes);
 }
 
-static MetaDeviceFile *
-meta_kms_impl_device_open_device_file (MetaKmsImplDevice  *impl_device,
-                                       const char         *path,
-                                       GError            **error)
-{
-  MetaKmsImplDevicePrivate *priv =
-    meta_kms_impl_device_get_instance_private (impl_device);
-  MetaKmsImplDeviceClass *klass = META_KMS_IMPL_DEVICE_GET_CLASS (impl_device);
-
-  return klass->open_device_file (impl_device, priv->path, error);
-}
-
-static gboolean
-ensure_device_file (MetaKmsImplDevice  *impl_device,
-                    GError            **error)
-{
-  MetaKmsImplDevicePrivate *priv =
-    meta_kms_impl_device_get_instance_private (impl_device);
-  MetaDeviceFile *device_file;
-
-  if (priv->device_file)
-    return TRUE;
-
-  device_file = meta_kms_impl_device_open_device_file (impl_device,
-                                                       priv->path,
-                                                       error);
-  if (!device_file)
-    return FALSE;
-
-  priv->device_file = device_file;
-
-  if (!(priv->flags & META_KMS_DEVICE_FLAG_NO_MODE_SETTING))
-    {
-      priv->fd_source =
-        meta_thread_impl_register_fd (META_THREAD_IMPL (priv->impl),
-                                      meta_device_file_get_fd (device_file),
-                                      kms_event_dispatch_in_impl,
-                                      impl_device);
-      g_source_set_priority (priv->fd_source, G_PRIORITY_HIGH);
-    }
-
-  return TRUE;
-}
-
 static void
 ensure_latched_fd_hold (MetaKmsImplDevice *impl_device)
 {
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index d32e06630..dd6a224ed 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -132,6 +132,23 @@ const char * meta_kms_impl_device_get_driver_description (MetaKmsImplDevice *imp
 
 const char * meta_kms_impl_device_get_path (MetaKmsImplDevice *impl_device);
 
+gboolean meta_kms_impl_device_lease_objects (MetaKmsImplDevice  *impl_device,
+                                             GList              *connectors,
+                                             GList              *crtcs,
+                                             GList              *planes,
+                                             int                *out_fd,
+                                             uint32_t           *out_lessee_id,
+                                             GError            **error);
+
+gboolean meta_kms_impl_device_revoke_lease (MetaKmsImplDevice  *impl_device,
+                                            uint32_t            lessee_id,
+                                            GError            **error);
+
+gboolean meta_kms_impl_device_list_lessees (MetaKmsImplDevice  *impl_device,
+                                            uint32_t          **out_lessee_ids,
+                                            int                *out_num_lessee_ids,
+                                            GError            **error);
+
 gboolean meta_kms_impl_device_dispatch (MetaKmsImplDevice  *impl_device,
                                         GError            **error);
 
-- 
2.45.0


From b6c0d58db1ecd8ee649f22d23ef132f1697aa657 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 17 Oct 2023 18:25:45 +0200
Subject: [PATCH 32/44] udev: Listen for lease events

Lease events are sent when drm leases disappear. This event will help us
track leased out drm resources.
---
 src/backends/native/meta-kms.c  | 21 +++++++++++++++++++++
 src/backends/native/meta-udev.c | 11 +++++++++++
 2 files changed, 32 insertions(+)

diff --git a/src/backends/native/meta-kms.c b/src/backends/native/meta-kms.c
index 868d30e4a..0670e54bf 100644
--- a/src/backends/native/meta-kms.c
+++ b/src/backends/native/meta-kms.c
@@ -35,6 +35,7 @@ enum
 {
   RESOURCES_CHANGED,
   DEVICE_ADDED,
+  LEASE_CHANGED,
 
   N_SIGNALS
 };
@@ -48,6 +49,7 @@ struct _MetaKms
   MetaKmsFlags flags;
 
   gulong hotplug_handler_id;
+  gulong lease_handler_id;
   gulong removed_handler_id;
 
   MetaKmsImpl *impl;
@@ -308,6 +310,14 @@ on_udev_device_removed (MetaUdev    *udev,
   handle_hotplug_event (kms, NULL, META_KMS_RESOURCE_CHANGE_NONE);
 }
 
+static void
+on_udev_lease (MetaUdev    *udev,
+               GUdevDevice *udev_device,
+               MetaKms     *kms)
+{
+  g_signal_emit (kms, signals[LEASE_CHANGED], 0);
+}
+
 MetaBackend *
 meta_kms_get_backend (MetaKms *kms)
 {
@@ -398,6 +408,8 @@ meta_kms_new (MetaBackend   *backend,
     {
       kms->hotplug_handler_id =
         g_signal_connect (udev, "hotplug", G_CALLBACK (on_udev_hotplug), kms);
+      kms->lease_handler_id =
+        g_signal_connect (udev, "lease", G_CALLBACK (on_udev_lease), kms);
     }
 
   kms->removed_handler_id =
@@ -422,6 +434,7 @@ meta_kms_finalize (GObject *object)
   g_list_free_full (kms->devices, g_object_unref);
 
   g_clear_signal_handler (&kms->hotplug_handler_id, udev);
+  g_clear_signal_handler (&kms->lease_handler_id, udev);
   g_clear_signal_handler (&kms->removed_handler_id, udev);
 
   G_OBJECT_CLASS (meta_kms_parent_class)->finalize (object);
@@ -459,6 +472,14 @@ meta_kms_class_init (MetaKmsClass *klass)
                   G_TYPE_NONE, 1,
                   META_TYPE_KMS_DEVICE);
 
+  signals[LEASE_CHANGED] =
+    g_signal_new ("lease-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+
   meta_thread_class_register_impl_type (thread_class, META_TYPE_KMS_IMPL);
 }
 
diff --git a/src/backends/native/meta-udev.c b/src/backends/native/meta-udev.c
index 097e8a283..c6974b9c6 100644
--- a/src/backends/native/meta-udev.c
+++ b/src/backends/native/meta-udev.c
@@ -28,6 +28,7 @@
 enum
 {
   HOTPLUG,
+  LEASE,
   DEVICE_ADDED,
   DEVICE_REMOVED,
 
@@ -221,6 +222,9 @@ on_uevent (GUdevClient *client,
 
   if (g_udev_device_get_property_as_boolean (device, "HOTPLUG"))
     g_signal_emit (udev, signals[HOTPLUG], 0, device);
+
+  if (g_udev_device_get_property_as_boolean (device, "LEASE"))
+    g_signal_emit (udev, signals[LEASE], 0, device);
 }
 
 MetaUdev *
@@ -282,6 +286,13 @@ meta_udev_class_init (MetaUdevClass *klass)
                   0, NULL, NULL, NULL,
                   G_TYPE_NONE, 1,
                   G_UDEV_TYPE_DEVICE);
+  signals[LEASE] =
+    g_signal_new ("lease",
+                  G_TYPE_FROM_CLASS (object_class),
+                  G_SIGNAL_RUN_LAST,
+                  0, NULL, NULL, NULL,
+                  G_TYPE_NONE, 1,
+                  G_UDEV_TYPE_DEVICE);
   signals[DEVICE_ADDED] =
     g_signal_new ("device-added",
                   G_TYPE_FROM_CLASS (object_class),
-- 
2.45.0


From dd2587b4ce8c98ca0b8ac552ee2961000110b431 Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 16 Jan 2024 16:37:49 +0100
Subject: [PATCH 33/44] native/crtc-kms: Unset config of CRTCs which are not
 part of a modeset

This allows us to keep track when primary and cursor plane assignments
on a CRTC are unassigned. With this commit, all planes which are
assigned are actually in use and can't be assigned to anything else.

We'll make use of that fact when we search for a leasable primary plane.
---
 src/backends/meta-crtc.c            |  4 ++++
 src/backends/meta-crtc.h            |  2 ++
 src/backends/native/meta-crtc-kms.c | 21 +++++++++++++++++----
 3 files changed, 23 insertions(+), 4 deletions(-)

diff --git a/src/backends/meta-crtc.c b/src/backends/meta-crtc.c
index bca008ea9..71b9bcbe9 100644
--- a/src/backends/meta-crtc.c
+++ b/src/backends/meta-crtc.c
@@ -130,6 +130,10 @@ void
 meta_crtc_unset_config (MetaCrtc *crtc)
 {
   MetaCrtcPrivate *priv = meta_crtc_get_instance_private (crtc);
+  MetaCrtcClass *klass = META_CRTC_GET_CLASS (crtc);
+
+  if (klass->unset_config)
+    klass->unset_config (crtc);
 
   g_clear_pointer (&priv->config, g_free);
 }
diff --git a/src/backends/meta-crtc.h b/src/backends/meta-crtc.h
index 68ff58ea8..3c6abfe35 100644
--- a/src/backends/meta-crtc.h
+++ b/src/backends/meta-crtc.h
@@ -56,6 +56,8 @@ struct _MetaCrtcClass
                        const MetaCrtcConfig *config,
                        gpointer              backend_private);
 
+  void (* unset_config) (MetaCrtc *crtc);
+
   gboolean (* is_leased) (MetaCrtc *crtc);
 };
 
diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 1b426d76d..2d2deab1b 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -206,6 +206,15 @@ meta_crtc_kms_set_gamma_lut (MetaCrtc           *crtc,
   clutter_stage_schedule_update (CLUTTER_STAGE (stage));
 }
 
+static gboolean
+meta_crtc_kms_is_leased (MetaCrtc *crtc)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+
+  return meta_kms_crtc_is_leased (kms_crtc);
+}
+
 typedef struct _CrtcKmsAssignment
 {
   MetaKmsPlane *primary_plane;
@@ -326,13 +335,16 @@ meta_crtc_kms_set_config (MetaCrtc             *crtc,
   crtc_kms->assigned_cursor_plane = kms_assignment->cursor_plane;
 }
 
-static gboolean
-meta_crtc_kms_is_leased (MetaCrtc *crtc)
+static void
+meta_crtc_kms_unset_config (MetaCrtc *crtc)
 {
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
-  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
 
-  return meta_kms_crtc_is_leased (kms_crtc);
+  if (meta_crtc_kms_is_leased (crtc))
+    return;
+
+  crtc_kms->assigned_primary_plane = NULL;
+  crtc_kms->assigned_cursor_plane = NULL;
 }
 
 static gboolean
@@ -485,6 +497,7 @@ meta_crtc_kms_class_init (MetaCrtcKmsClass *klass)
   crtc_class->set_gamma_lut = meta_crtc_kms_set_gamma_lut;
   crtc_class->assign_extra = meta_crtc_kms_assign_extra;
   crtc_class->set_config = meta_crtc_kms_set_config;
+  crtc_class->unset_config = meta_crtc_kms_unset_config;
   crtc_class->is_leased = meta_crtc_kms_is_leased;
 
   crtc_native_class->is_transform_handled = meta_crtc_kms_is_transform_handled;
-- 
2.45.0


From cccf9b72e80df6a362c1a9dec020d6358cbb926e Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 16 Jan 2024 16:47:16 +0100
Subject: [PATCH 34/44] native/crtc-kms: Don't assign leased primary planes to
 CRTCs

When a plane is leased, it is assigned to a CRTC which is leased. When
trying to find a primary plane for a modeset, skip the assigned planes
on leased CRTCs to avoid sharing the resources with the leased process.
---
 src/backends/native/meta-crtc-kms.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 2d2deab1b..90c539196 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -256,6 +256,25 @@ is_plane_assigned (MetaKmsPlane     *plane,
   return FALSE;
 }
 
+static gboolean
+is_plane_leased (MetaKmsDevice *kms_device,
+                 MetaKmsPlane  *kms_plane)
+{
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (kms_device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+
+      if (meta_kms_crtc_is_leased (kms_crtc) &&
+          crtc_kms->assigned_primary_plane == kms_plane)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
 static MetaKmsPlane *
 find_unassigned_plane (MetaCrtcKms      *crtc_kms,
                        MetaKmsPlaneType  kms_plane_type,
@@ -279,6 +298,9 @@ find_unassigned_plane (MetaCrtcKms      *crtc_kms,
                              crtc_assignments))
         continue;
 
+      if (is_plane_leased (kms_device, kms_plane))
+        continue;
+
       return kms_plane;
     }
 
-- 
2.45.0


From 99b7176fc9de8711a0cdb3e7f858d686649b298e Mon Sep 17 00:00:00 2001
From: Sebastian Wick <sebastian.wick@redhat.com>
Date: Tue, 17 Oct 2023 18:30:25 +0200
Subject: [PATCH 35/44] native/kms-lease: Implement leasing out a set of
 connectors

The manager keeps track of which connectors are leasable in general,
which connectors and resources are already part of a lease, and keeps
track of when leases get revoked.

When leasing out connectors, the required drm resources to drive the
connectors are included in the lease as well.
---
 src/backends/native/meta-crtc-kms.c         |   9 +
 src/backends/native/meta-crtc-kms.h         |   4 +
 src/backends/native/meta-kms-crtc-private.h |   3 +
 src/backends/native/meta-kms-crtc.c         |   7 +
 src/backends/native/meta-kms-lease.c        | 791 ++++++++++++++++++++
 src/backends/native/meta-kms-lease.h        |  53 ++
 src/meson.build                             |   2 +
 7 files changed, 869 insertions(+)
 create mode 100644 src/backends/native/meta-kms-lease.c
 create mode 100644 src/backends/native/meta-kms-lease.h

diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 90c539196..37ad24273 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -357,6 +357,15 @@ meta_crtc_kms_set_config (MetaCrtc             *crtc,
   crtc_kms->assigned_cursor_plane = kms_assignment->cursor_plane;
 }
 
+void
+meta_crtc_kms_assign_plane (MetaCrtcKms  *crtc_kms,
+                            MetaKmsPlane *primary_plane,
+                            MetaKmsPlane *cursor_plane)
+{
+  crtc_kms->assigned_primary_plane = primary_plane;
+  crtc_kms->assigned_cursor_plane = cursor_plane;
+}
+
 static void
 meta_crtc_kms_unset_config (MetaCrtc *crtc)
 {
diff --git a/src/backends/native/meta-crtc-kms.h b/src/backends/native/meta-crtc-kms.h
index c132b9907..68c03fc1f 100644
--- a/src/backends/native/meta-crtc-kms.h
+++ b/src/backends/native/meta-crtc-kms.h
@@ -41,6 +41,10 @@ MetaKmsPlane * meta_crtc_kms_get_assigned_primary_plane (MetaCrtcKms *crtc_kms);
 
 MetaKmsPlane * meta_crtc_kms_get_assigned_cursor_plane (MetaCrtcKms *crtc_kms);
 
+void meta_crtc_kms_assign_plane (MetaCrtcKms  *crtc_kms,
+                                 MetaKmsPlane *primary_plane,
+                                 MetaKmsPlane *cursor_plane);
+
 void meta_crtc_kms_set_mode (MetaCrtcKms   *crtc_kms,
                              MetaKmsUpdate *kms_update);
 
diff --git a/src/backends/native/meta-kms-crtc-private.h b/src/backends/native/meta-kms-crtc-private.h
index 299482d6e..237a73625 100644
--- a/src/backends/native/meta-kms-crtc-private.h
+++ b/src/backends/native/meta-kms-crtc-private.h
@@ -58,3 +58,6 @@ gboolean meta_kms_crtc_determine_deadline (MetaKmsCrtc  *crtc,
                                            int64_t      *out_next_deadline_us,
                                            int64_t      *out_next_presentation_us,
                                            GError      **error);
+
+void meta_kms_crtc_set_is_leased (MetaKmsCrtc *crtc,
+                                  gboolean     leased);
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index 6ca1c08d3..40237fff9 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -115,6 +115,13 @@ meta_kms_crtc_is_leased (MetaKmsCrtc *crtc)
   return crtc->is_leased;
 }
 
+void
+meta_kms_crtc_set_is_leased (MetaKmsCrtc *crtc,
+                             gboolean     leased)
+{
+  crtc->is_leased = leased;
+}
+
 static void
 read_crtc_gamma (MetaKmsCrtc       *crtc,
                  MetaKmsCrtcState  *crtc_state,
diff --git a/src/backends/native/meta-kms-lease.c b/src/backends/native/meta-kms-lease.c
new file mode 100644
index 000000000..b1e95cfac
--- /dev/null
+++ b/src/backends/native/meta-kms-lease.c
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2023 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include "backends/native/meta-kms-lease.h"
+
+#include <glib.h>
+
+#include "backends/native/meta-crtc-kms.h"
+#include "backends/native/meta-kms.h"
+#include "backends/native/meta-kms-connector.h"
+#include "backends/native/meta-kms-crtc-private.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-kms-plane.h"
+
+enum
+{
+  PROP_0,
+
+  PROP_MANAGER_BACKEND_NATIVE,
+
+  N_PROPS_MANAGER,
+};
+
+static GParamSpec *props_manager[N_PROPS_MANAGER] = { NULL };
+
+enum
+{
+  MANAGER_CONNECTORS_CHANGED,
+
+  N_SIGNALS_MANAGER,
+};
+
+static guint signals_manager[N_SIGNALS_MANAGER] = { 0 };
+
+enum
+{
+  LEASE_REVOKED,
+
+  N_SIGNALS_LEASE,
+};
+
+static guint signals_lease[N_SIGNALS_LEASE] = { 0 };
+
+struct _MetaKmsLeaseManager
+{
+  GObject parent;
+
+  MetaBackendNative *backend_native;
+
+  gulong device_added_handler_id;
+  gulong resources_changed_handler_id;
+  gulong lease_changed_handler_id;
+
+  GHashTable *leases;
+  GHashTable *connectors;
+};
+
+G_DEFINE_TYPE (MetaKmsLeaseManager, meta_kms_lease_manager, G_TYPE_OBJECT)
+
+typedef struct _LeasingKmsAssignment
+{
+  MetaKmsConnector *connector;
+  MetaKmsCrtc *crtc;
+  MetaKmsPlane *primary_plane;
+  MetaKmsPlane *cursor_plane;
+} LeasingKmsAssignment;
+
+struct _MetaKmsLease
+{
+  GObject parent;
+
+  uint32_t lessee_id;
+  int fd;
+  MetaKmsDevice *kms_device;
+  GList *assignments;
+};
+
+G_DEFINE_TYPE (MetaKmsLease, meta_kms_lease, G_TYPE_OBJECT)
+
+static MetaKmsCrtc *
+find_crtc_to_lease (MetaKmsConnector *kms_connector)
+{
+  MetaKmsDevice *device = meta_kms_connector_get_device (kms_connector);
+  const MetaKmsConnectorState *connector_state =
+    meta_kms_connector_get_current_state (kms_connector);
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+      uint32_t crtc_idx;
+
+      if (meta_crtc_is_leased (META_CRTC (crtc_kms)))
+        continue;
+
+      if (meta_crtc_get_outputs (META_CRTC (crtc_kms)) != NULL)
+        continue;
+
+      crtc_idx = meta_kms_crtc_get_idx (kms_crtc);
+      if (!(connector_state->common_possible_crtcs & (1 << crtc_idx)))
+        continue;
+
+      return kms_crtc;
+    }
+
+  return NULL;
+}
+
+static gboolean
+is_plane_assigned (MetaKmsDevice *kms_device,
+                   MetaKmsPlane  *kms_plane)
+{
+  GList *l;
+
+  for (l = meta_kms_device_get_crtcs (kms_device); l; l = l->next)
+    {
+      MetaKmsCrtc *kms_crtc = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (kms_crtc);
+
+      if (meta_crtc_kms_get_assigned_primary_plane (crtc_kms) == kms_plane)
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static MetaKmsPlane *
+find_plane_to_lease (MetaKmsCrtc      *kms_crtc,
+                     MetaKmsPlaneType  plane_type)
+{
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  GList *l;
+
+  for (l = meta_kms_device_get_planes (kms_device); l; l = l->next)
+    {
+      MetaKmsPlane *kms_plane = l->data;
+
+      if (meta_kms_plane_get_plane_type (kms_plane) != plane_type)
+        continue;
+
+      if (!meta_kms_plane_is_usable_with (kms_plane, kms_crtc))
+        continue;
+
+      if (is_plane_assigned (kms_device, kms_plane))
+        continue;
+
+      return kms_plane;
+    }
+
+  return NULL;
+}
+
+static MetaKmsDevice *
+find_resources_to_lease (GList   *connectors,
+                         GList  **out_assignments,
+                         GList  **out_crtcs,
+                         GList  **out_planes,
+                         GError **error)
+{
+  MetaKmsDevice *kms_device = NULL;
+  g_autoptr (GList) assignments = NULL;
+  g_autoptr (GList) crtcs = NULL;
+  g_autoptr (GList) planes = NULL;
+  GList *l;
+
+  if (connectors == NULL)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                   "Cannot create lease without connectors");
+      return NULL;
+    }
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+      MetaKmsDevice *connector_device;
+
+      connector_device =
+        meta_kms_connector_get_device (connector);
+
+      if (kms_device != NULL && kms_device != connector_device)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                       "Cannot create lease on multiple devices");
+          return NULL;
+        }
+
+      kms_device = connector_device;
+    }
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+      LeasingKmsAssignment *assignment;
+      MetaKmsCrtc *crtc;
+      MetaKmsPlane *primary_plane;
+      MetaKmsPlane *cursor_plane;
+
+      crtc = find_crtc_to_lease (connector);
+      if (!crtc)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                       "Failed to find CRTC to lease with connector %u (%s)",
+                       meta_kms_connector_get_id (connector),
+                       meta_kms_device_get_path (kms_device));
+          return NULL;
+        }
+
+      crtcs = g_list_append (crtcs, crtc);
+
+      primary_plane = find_plane_to_lease (crtc, META_KMS_PLANE_TYPE_PRIMARY);
+      if (!primary_plane)
+        {
+          g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
+                       "Failed to find primary plane "
+                       "to lease with connector %u (%s)",
+                       meta_kms_connector_get_id (connector),
+                       meta_kms_device_get_path (kms_device));
+          return NULL;
+        }
+
+      planes = g_list_append (planes, primary_plane);
+
+      cursor_plane = find_plane_to_lease (crtc, META_KMS_PLANE_TYPE_CURSOR);
+      if (!cursor_plane)
+        {
+          g_warning ("Failed to find cursor plane "
+                     "to lease with connector %u (%s)",
+                     meta_kms_connector_get_id (connector),
+                     meta_kms_device_get_path (kms_device));
+        }
+      else
+        {
+          planes = g_list_append (planes, cursor_plane);
+        }
+
+      assignment = g_new0 (LeasingKmsAssignment, 1);
+      assignment->connector = connector;
+      assignment->crtc = crtc;
+      assignment->primary_plane = primary_plane;
+      assignment->cursor_plane = cursor_plane;
+
+      assignments = g_list_append (assignments, assignment);
+    }
+
+  *out_assignments = g_steal_pointer (&assignments);
+  *out_crtcs = g_steal_pointer (&crtcs);
+  *out_planes = g_steal_pointer (&planes);
+  return kms_device;
+}
+
+uint32_t
+meta_kms_lease_get_id (MetaKmsLease *lease)
+{
+  return lease->lessee_id;
+}
+
+int
+meta_kms_lease_steal_fd (MetaKmsLease *lease)
+{
+  int fd = lease->fd;
+  lease->fd = -1;
+  return fd;
+}
+
+gboolean
+meta_kms_lease_is_active (MetaKmsLease *lease)
+{
+  return lease->lessee_id != 0;
+}
+
+static void
+meta_kms_lease_assign (MetaKmsLease *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (assignment->crtc);
+
+      meta_kms_crtc_set_is_leased (assignment->crtc, TRUE);
+      meta_crtc_kms_assign_plane (crtc_kms,
+                                  assignment->primary_plane,
+                                  assignment->cursor_plane);
+    }
+}
+
+static void
+meta_kms_lease_unassign (MetaKmsLease *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaCrtcKms *crtc_kms = meta_crtc_kms_from_kms_crtc (assignment->crtc);
+
+      meta_kms_crtc_set_is_leased (assignment->crtc, FALSE);
+      meta_crtc_kms_assign_plane (crtc_kms, NULL, NULL);
+    }
+}
+
+static void
+mark_revoked (MetaKmsLease *lease)
+{
+  meta_kms_lease_unassign (lease);
+
+  g_signal_emit (lease, signals_lease[LEASE_REVOKED], 0);
+  lease->lessee_id = 0;
+}
+
+void
+meta_kms_lease_revoke (MetaKmsLease *lease)
+{
+  g_autoptr (GError) error;
+
+  if (!lease->lessee_id)
+    return;
+
+  if (!meta_kms_device_revoke_lease (lease->kms_device, lease->lessee_id, &error))
+    {
+      g_warning ("Failed to revoke DRM lease on %s: %s",
+                 meta_kms_device_get_path (lease->kms_device),
+                 error->message);
+      return;
+    }
+
+  mark_revoked (lease);
+}
+
+static void
+meta_kms_lease_disappeared (MetaKmsLease *lease)
+{
+  mark_revoked (lease);
+}
+
+static void
+meta_kms_lease_dispose (GObject *object)
+{
+  MetaKmsLease *lease = META_KMS_LEASE (object);
+
+  g_clear_object (&lease->kms_device);
+
+  if (lease->assignments)
+    {
+      g_list_free_full (lease->assignments, g_free);
+      lease->assignments = NULL;
+    }
+
+  G_OBJECT_CLASS (meta_kms_lease_parent_class)->dispose (object);
+}
+
+static void
+meta_kms_lease_finalize (GObject *object)
+{
+  MetaKmsLease *lease = META_KMS_LEASE (object);
+
+  close (lease->fd);
+
+  G_OBJECT_CLASS (meta_kms_lease_parent_class)->finalize (object);
+}
+
+static void
+meta_kms_lease_class_init (MetaKmsLeaseClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->dispose = meta_kms_lease_dispose;
+  object_class->finalize = meta_kms_lease_finalize;
+
+  signals_lease[LEASE_REVOKED] =
+    g_signal_new ("revoked",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
+
+static void
+meta_kms_lease_init (MetaKmsLease *lease)
+{
+}
+
+static void
+on_lease_revoked (MetaKmsLease        *lease,
+                  MetaKmsLeaseManager *lease_manager)
+{
+  GHashTableIter iter;
+  MetaKmsConnector *connector;
+  MetaKmsLease *other_lease;
+
+  g_signal_handlers_disconnect_by_func (lease,
+                                        on_lease_revoked,
+                                        lease_manager);
+
+  g_hash_table_iter_init (&iter, lease_manager->connectors);
+  while (g_hash_table_iter_next (&iter,
+                                 (gpointer *)&connector,
+                                 (gpointer *)&other_lease))
+    {
+      if (lease == other_lease)
+        g_hash_table_insert (lease_manager->connectors, connector, NULL);
+    }
+
+  g_hash_table_remove (lease_manager->leases,
+                       GUINT_TO_POINTER (lease->lessee_id));
+
+  g_signal_emit (lease_manager, signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+}
+
+MetaKmsLease *
+meta_kms_lease_manager_lease_connectors (MetaKmsLeaseManager  *lease_manager,
+                                         GList                *connectors,
+                                         GError              **error)
+{
+  MetaKmsLease *lease;
+  g_autoptr (GList) assignments = NULL;
+  g_autoptr (GList) crtcs = NULL;
+  g_autoptr (GList) planes = NULL;
+  MetaKmsDevice *kms_device = NULL;
+  int fd;
+  uint32_t lessee_id;
+  GList *l;
+
+  kms_device = find_resources_to_lease (connectors,
+                                        &assignments,
+                                        &crtcs,
+                                        &planes,
+                                        error);
+  if (!kms_device)
+    return NULL;
+
+  if (!meta_kms_device_lease_objects (kms_device,
+                                      connectors, crtcs, planes,
+                                      &fd, &lessee_id,
+                                      error))
+    return NULL;
+
+  // FIXME: do we need to ref all the objects?
+  lease = g_object_new (META_TYPE_KMS_LEASE, NULL);
+  lease->lessee_id = lessee_id;
+  lease->fd = fd;
+  lease->kms_device = g_object_ref (kms_device);
+  lease->assignments = g_steal_pointer (&assignments);
+
+  meta_kms_lease_assign (lease);
+
+  g_signal_connect_after (lease, "revoked", G_CALLBACK (on_lease_revoked),
+                          lease_manager);
+
+  for (l = connectors; l; l = l->next)
+    {
+      MetaKmsConnector *connector = l->data;
+
+      g_hash_table_insert (lease_manager->connectors,
+                           connector, lease);
+    }
+
+  g_hash_table_insert (lease_manager->leases,
+                       GUINT_TO_POINTER (lessee_id), g_object_ref (lease));
+
+  g_signal_emit (lease_manager,
+                 signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+
+  return lease;
+}
+
+GList *
+meta_kms_lease_manager_get_connectors (MetaKmsLeaseManager *lease_manager)
+{
+  return g_hash_table_get_keys (lease_manager->connectors);
+}
+
+MetaKmsConnector *
+meta_kms_lease_manager_get_connector_from_id (MetaKmsLeaseManager *lease_manager,
+                                              uint32_t             connector_id)
+{
+  GHashTableIter iter;
+  MetaKmsConnector *connector;
+
+  g_hash_table_iter_init (&iter, lease_manager->connectors);
+  while (g_hash_table_iter_next (&iter, (gpointer *)&connector, NULL))
+    {
+      if (meta_kms_connector_get_id (connector) == connector_id)
+        return connector;
+    }
+
+  return NULL;
+}
+
+MetaKmsLease *
+meta_kms_lease_manager_get_lease_from_connector (MetaKmsLeaseManager *lease_manager,
+                                                 MetaKmsConnector    *kms_connector)
+{
+  return g_hash_table_lookup (lease_manager->connectors, kms_connector);
+}
+
+
+
+MetaKmsLease *
+meta_kms_lease_manager_get_lease_from_id (MetaKmsLeaseManager *lease_manager,
+                                          uint32_t             lessee_id)
+{
+  return g_hash_table_lookup (lease_manager->leases,
+                              GUINT_TO_POINTER (lessee_id));
+}
+
+static void
+update_connectors (MetaKmsLeaseManager *lease_manager)
+{
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+  GHashTable *new_connectors;
+  MetaKmsLease *lease;
+  GList *l;
+  GList *o;
+  gboolean has_new = FALSE;
+
+  new_connectors = g_hash_table_new_similar (lease_manager->connectors);
+
+  for (l = meta_kms_get_devices (kms); l; l = l->next)
+    {
+      MetaKmsDevice *kms_device = l->data;
+
+      for (o = meta_kms_device_get_connectors (kms_device); o; o = o->next)
+        {
+          MetaKmsConnector *kms_connector = o->data;
+
+          if (!meta_kms_connector_is_for_lease (kms_connector))
+            continue;
+
+          if (!g_hash_table_steal_extended (lease_manager->connectors,
+                                            kms_connector,
+                                            NULL, (gpointer *) &lease))
+            has_new = TRUE;
+          g_hash_table_insert (new_connectors, kms_connector, lease);
+        }
+    }
+
+  if (has_new || g_hash_table_size (lease_manager->connectors) != 0)
+    {
+      g_signal_emit (lease_manager,
+                     signals_manager[MANAGER_CONNECTORS_CHANGED], 0);
+    }
+
+  g_clear_pointer (&lease_manager->connectors, g_hash_table_unref);
+  lease_manager->connectors = new_connectors;
+}
+
+static void
+lease_disappeared (MetaKmsLeaseManager *lease_manager,
+                   MetaKmsLease        *lease)
+{
+  GList *l;
+
+  for (l = lease->assignments; l; l = l->next)
+    {
+      LeasingKmsAssignment *assignment = l->data;
+      MetaKmsConnector *kms_connector = assignment->connector;
+
+      if (g_hash_table_lookup_extended (lease_manager->connectors,
+                                        kms_connector,
+                                        NULL, NULL))
+        g_hash_table_insert (lease_manager->connectors, kms_connector, NULL);
+    }
+
+  meta_kms_lease_disappeared (lease);
+}
+
+static gboolean
+did_lease_disappear (MetaKmsLease  *lease,
+                     uint32_t      *lessees,
+                     int            num_lessees,
+                     MetaKmsDevice *kms_device)
+{
+  int i;
+
+  if (lease->kms_device != kms_device)
+    return FALSE;
+
+  for (i = 0; i < num_lessees; i++)
+    {
+      if (lease->lessee_id == lessees[i])
+        return FALSE;
+    }
+
+  return TRUE;
+}
+
+static void
+update_leases (MetaKmsLeaseManager *lease_manager)
+{
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+  MetaKmsLease *lease;
+  GList *l;
+  g_autoptr (GList) disappeared_leases = NULL;
+
+  for (l = meta_kms_get_devices (kms); l; l = l->next)
+    {
+      MetaKmsDevice *kms_device = l->data;
+      g_autofree uint32_t *lessees = NULL;
+      int num_lessees;
+      g_autoptr (GError) error = NULL;
+      GHashTableIter iter;
+
+      if (!meta_kms_device_list_lessees (kms_device,
+                                         &lessees, &num_lessees,
+                                         &error))
+        {
+          g_warning ("Failed to list leases: %s", error->message);
+          continue;
+        }
+
+      g_hash_table_iter_init (&iter, lease_manager->leases);
+      while (g_hash_table_iter_next (&iter, NULL, (gpointer *)&lease))
+        {
+          if (did_lease_disappear (lease, lessees, num_lessees, kms_device))
+            disappeared_leases = g_list_append (disappeared_leases, lease);
+        }
+
+      g_free (lessees);
+    }
+
+  for (l = disappeared_leases; l; l = l->next)
+    {
+      lease = l->data;
+
+      lease_disappeared (lease_manager, lease);
+    }
+}
+
+static void
+on_device_added (MetaKms             *kms,
+                 MetaKmsDevice       *kms_device,
+                 MetaKmsLeaseManager *lease_manager)
+{
+  update_connectors (lease_manager);
+}
+
+static void
+on_resources_changed (MetaKms                *kms,
+                      MetaKmsResourceChanges  changes,
+                      MetaKmsLeaseManager    *lease_manager)
+{
+  if (changes != META_KMS_RESOURCE_CHANGE_FULL)
+    return;
+
+  update_connectors (lease_manager);
+}
+
+static void
+on_lease_changed (MetaKms             *kms,
+                  MetaKmsLeaseManager *lease_manager)
+{
+  update_leases (lease_manager);
+}
+
+static void
+meta_kms_lease_manager_constructed (GObject *object)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+
+  lease_manager->device_added_handler_id =
+    g_signal_connect (kms, "device-added",
+                      G_CALLBACK (on_device_added),
+                      lease_manager);
+  lease_manager->resources_changed_handler_id =
+    g_signal_connect (kms, "resources-changed",
+                      G_CALLBACK (on_resources_changed),
+                      lease_manager);
+  lease_manager->lease_changed_handler_id =
+    g_signal_connect (kms, "lease-changed",
+                      G_CALLBACK (on_lease_changed),
+                      lease_manager);
+
+  lease_manager->leases =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) g_object_unref);
+
+  lease_manager->connectors =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL, NULL);
+
+  update_connectors (lease_manager);
+
+  G_OBJECT_CLASS (meta_kms_lease_manager_parent_class)->constructed (object);
+}
+
+static void
+meta_kms_lease_manager_set_property (GObject      *object,
+                                     guint         prop_id,
+                                     const GValue *value,
+                                     GParamSpec   *pspec)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  switch (prop_id)
+    {
+    case PROP_MANAGER_BACKEND_NATIVE:
+      lease_manager->backend_native = g_value_get_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_kms_lease_manager_get_property (GObject    *object,
+                                     guint       prop_id,
+                                     GValue     *value,
+                                     GParamSpec *pspec)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  switch (prop_id)
+    {
+    case PROP_MANAGER_BACKEND_NATIVE:
+      g_value_set_object (value, lease_manager->backend_native);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+    }
+}
+
+static void
+meta_kms_lease_manager_dispose (GObject *object)
+{
+  MetaKmsLeaseManager *lease_manager = META_KMS_LEASE_MANAGER (object);
+  MetaKms *kms = meta_backend_native_get_kms (lease_manager->backend_native);
+
+  g_clear_signal_handler (&lease_manager->device_added_handler_id, kms);
+  g_clear_signal_handler (&lease_manager->resources_changed_handler_id, kms);
+  g_clear_signal_handler (&lease_manager->lease_changed_handler_id, kms);
+
+  g_clear_pointer (&lease_manager->leases, g_hash_table_unref);
+  g_clear_pointer (&lease_manager->connectors, g_hash_table_unref);
+
+  G_OBJECT_CLASS (meta_kms_lease_manager_parent_class)->dispose (object);
+}
+
+static void
+meta_kms_lease_manager_class_init (MetaKmsLeaseManagerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->constructed = meta_kms_lease_manager_constructed;
+  object_class->set_property = meta_kms_lease_manager_set_property;
+  object_class->get_property = meta_kms_lease_manager_get_property;
+  object_class->dispose = meta_kms_lease_manager_dispose;
+
+  props_manager[PROP_MANAGER_BACKEND_NATIVE] =
+    g_param_spec_object ("backend-native", NULL, NULL,
+                         META_TYPE_BACKEND_NATIVE,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (object_class,
+                                     N_PROPS_MANAGER, props_manager);
+
+  signals_manager[MANAGER_CONNECTORS_CHANGED] =
+    g_signal_new ("connectors-changed",
+                  G_TYPE_FROM_CLASS (klass),
+                  G_SIGNAL_RUN_LAST,
+                  0,
+                  NULL, NULL, NULL,
+                  G_TYPE_NONE, 0);
+}
+
+static void
+meta_kms_lease_manager_init (MetaKmsLeaseManager *lease_manager)
+{
+}
diff --git a/src/backends/native/meta-kms-lease.h b/src/backends/native/meta-kms-lease.h
new file mode 100644
index 000000000..4cd569b53
--- /dev/null
+++ b/src/backends/native/meta-kms-lease.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2023 Red Hat
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <glib-object.h>
+
+#include "backends/native/meta-backend-native.h"
+
+#define META_TYPE_KMS_LEASE (meta_kms_lease_get_type ())
+G_DECLARE_FINAL_TYPE (MetaKmsLease, meta_kms_lease,
+                      META, KMS_LEASE, GObject)
+
+#define META_TYPE_KMS_LEASE_MANAGER (meta_kms_lease_manager_get_type ())
+G_DECLARE_FINAL_TYPE (MetaKmsLeaseManager, meta_kms_lease_manager,
+                      META, KMS_LEASE_MANAGER, GObject)
+
+uint32_t meta_kms_lease_get_id (MetaKmsLease *lease);
+
+int meta_kms_lease_steal_fd (MetaKmsLease *lease);
+
+gboolean meta_kms_lease_is_active (MetaKmsLease *lease);
+
+void meta_kms_lease_revoke (MetaKmsLease *lease);
+
+MetaKmsLease * meta_kms_lease_manager_lease_connectors (MetaKmsLeaseManager  *lease_manager,
+                                                        GList                *connectors,
+                                                        GError              **error);
+
+GList * meta_kms_lease_manager_get_connectors (MetaKmsLeaseManager *lease_manager);
+
+MetaKmsConnector * meta_kms_lease_manager_get_connector_from_id (MetaKmsLeaseManager *lease_manager,
+                                                                 uint32_t             connector_id);
+
+MetaKmsLease * meta_kms_lease_manager_get_lease_from_connector (MetaKmsLeaseManager *lease_manager,
+                                                                MetaKmsConnector    *kms_connector);
+
+MetaKmsLease * meta_kms_lease_manager_get_lease_from_id (MetaKmsLeaseManager *lease_manager,
+                                                         uint32_t             lessee_id);
diff --git a/src/meson.build b/src/meson.build
index 3060b2880..55fccb56d 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -806,6 +806,8 @@ if have_native_backend
     'backends/native/meta-kms-impl-device.h',
     'backends/native/meta-kms-impl.c',
     'backends/native/meta-kms-impl.h',
+    'backends/native/meta-kms-lease.c',
+    'backends/native/meta-kms-lease.h',
     'backends/native/meta-kms-mode.c',
     'backends/native/meta-kms-mode.h',
     'backends/native/meta-kms-page-flip.c',
-- 
2.45.0


From 0d2aa5decb25b34cfe24cc8b1f8df87e4ace758c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Exp=C3=B3sito?= <jexposit@redhat.com>
Date: Fri, 19 Apr 2024 16:54:40 +0200
Subject: [PATCH 36/44] kms/impl-device: Add function to get a non-master fd

Add meta_kms_impl_device_get_non_master_fd() that returns a non-master
file descriptor for a MetaKmsImplDevice.

It'll be required to implement wp_drm_lease_device_v1_send_drm_fd() in a
future commit.
---
 src/backends/native/meta-kms-impl-device.c | 45 ++++++++++++++++++++++
 src/backends/native/meta-kms-impl-device.h |  2 +
 2 files changed, 47 insertions(+)

diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index d6ef26729..9c4574ba2 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -20,6 +20,7 @@
 #include "backends/native/meta-kms-impl-device.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <glib/gstdio.h>
 #include <linux/dma-buf.h>
 #include <sys/ioctl.h>
@@ -1185,6 +1186,50 @@ meta_kms_impl_device_get_fd (MetaKmsImplDevice *impl_device)
   return meta_device_file_get_fd (priv->device_file);
 }
 
+/**
+ * meta_kms_impl_device_get_non_master_fd:
+ * @impl_device: a #MetaKmsImplDevice object
+ *
+ * Returns a non-master file descriptor for the given impl_device. The caller is
+ * responsable of closing the file descriptor.
+ *
+ * On error, returns a negative value.
+ */
+int
+meta_kms_impl_device_get_non_master_fd (MetaKmsImplDevice *impl_device)
+{
+  int fd;
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+
+  const char *path = meta_device_file_get_path (priv->device_file);
+  g_assert_nonnull (path);
+
+  fd = open (path, O_RDWR | O_CLOEXEC);
+  if (fd < 0)
+    {
+      meta_topic (META_DEBUG_KMS,
+                  "Error getting non-master fd for device at '%s': %s",
+                  path,
+                  g_strerror (errno));
+      return -1;
+    }
+
+  if (drmIsMaster (fd))
+    {
+      if (drmDropMaster (fd) < 0)
+        {
+          meta_topic (META_DEBUG_KMS,
+                      "Error dropping master for device at '%s'",
+                      path);
+          return -1;
+        }
+    }
+
+  g_assert_false (drmIsMaster (fd));
+  return fd;
+}
+
 /**
  * meta_kms_impl_device_get_signaled_sync_file:
  * @impl_device: a #MetaKmsImplDevice object
diff --git a/src/backends/native/meta-kms-impl-device.h b/src/backends/native/meta-kms-impl-device.h
index dd6a224ed..5cfc9bbbe 100644
--- a/src/backends/native/meta-kms-impl-device.h
+++ b/src/backends/native/meta-kms-impl-device.h
@@ -165,6 +165,8 @@ void meta_kms_impl_device_hold_fd (MetaKmsImplDevice *impl_device);
 
 void meta_kms_impl_device_unhold_fd (MetaKmsImplDevice *impl_device);
 
+int meta_kms_impl_device_get_non_master_fd (MetaKmsImplDevice *impl_device);
+
 int meta_kms_impl_device_get_signaled_sync_file (MetaKmsImplDevice *impl_device);
 
 MetaKmsResourceChanges meta_kms_impl_device_update_states (MetaKmsImplDevice *impl_device,
-- 
2.45.0


From 425f1bb7aab187310728e22d6fcd45c894f4de67 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Thu, 9 May 2024 11:35:02 +0200
Subject: [PATCH 37/44] wayland/drm-lease: Advertise initial devices
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Advertise one wp_drm_lease_device_v1 global for each DRM node.

Co-authored-by: José Expósito <jexposit@redhat.com>
---
 src/meson.build                      |   8 ++
 src/wayland/meta-wayland-drm-lease.c | 185 +++++++++++++++++++++++++++
 src/wayland/meta-wayland-drm-lease.h |  27 ++++
 src/wayland/meta-wayland-types.h     |   2 +
 src/wayland/meta-wayland-versions.h  |   1 +
 5 files changed, 223 insertions(+)
 create mode 100644 src/wayland/meta-wayland-drm-lease.c
 create mode 100644 src/wayland/meta-wayland-drm-lease.h

diff --git a/src/meson.build b/src/meson.build
index 55fccb56d..eaf90e41b 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -723,6 +723,13 @@ if have_wayland
       'wayland/meta-xwayland-surface.h',
     ]
   endif
+
+  if have_native_backend
+    mutter_sources += [
+      'wayland/meta-wayland-drm-lease.c',
+      'wayland/meta-wayland-drm-lease.h',
+    ]
+  endif
 endif
 
 if have_native_backend
@@ -1064,6 +1071,7 @@ if have_wayland
   #  - protocol stability ('private', 'stable' or 'unstable')
   #  - protocol version (if stability is 'unstable')
   wayland_protocols = [
+    ['drm-lease', 'staging', 'v1', ],
     ['fractional-scale', 'staging', 'v1', ],
     ['gtk-shell', 'private', ],
     ['idle-inhibit', 'unstable', 'v1', ],
diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
new file mode 100644
index 000000000..46da3b153
--- /dev/null
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2016 Red Hat Inc.
+ * Copyright (C) 2017 Intel Corporation
+ * Copyright (C) 2018,2019 DisplayLink (UK) Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include "wayland/meta-wayland-drm-lease.h"
+
+#include <glib.h>
+
+#include "backends/native/meta-backend-native.h"
+#include "backends/native/meta-kms-connector.h"
+#include "backends/native/meta-kms-device.h"
+#include "backends/native/meta-kms-device-private.h"
+#include "backends/native/meta-kms-impl-device.h"
+#include "backends/native/meta-kms.h"
+#include "backends/edid.h"
+#include "wayland/meta-wayland-private.h"
+
+#include "drm-lease-v1-server-protocol.h"
+
+struct _MetaWaylandDrmLeaseManager
+{
+  MetaWaylandCompositor *compositor;
+
+  /* Key:   MetaKmsDevice *kms_device
+   * Value: MetaWaylandDrmLeaseDevice *lease_device
+   */
+  GHashTable *devices;
+};
+
+typedef struct _MetaWaylandDrmLeaseDevice
+{
+  MetaWaylandDrmLeaseManager *lease_manager;
+
+  struct wl_global *global;
+  MetaKmsDevice *kms_device;
+
+  GList *resources;
+} MetaWaylandDrmLeaseDevice;
+
+static void
+meta_wayland_drm_lease_device_free (MetaWaylandDrmLeaseDevice *lease_device)
+{
+}
+
+static void
+meta_wayland_drm_lease_device_release (MetaWaylandDrmLeaseDevice *lease_device)
+{
+  g_rc_box_release_full (lease_device,
+                         (GDestroyNotify) meta_wayland_drm_lease_device_free);
+}
+
+static void
+wp_drm_lease_device_create_lease_request (struct wl_client   *client,
+                                          struct wl_resource *resource,
+                                          uint32_t            id)
+{
+}
+
+static void
+wp_drm_lease_device_release (struct wl_client   *client,
+                             struct wl_resource *resource)
+{
+}
+
+static const struct wp_drm_lease_device_v1_interface drm_lease_device_implementation = {
+  wp_drm_lease_device_create_lease_request,
+  wp_drm_lease_device_release,
+};
+
+static void
+wp_drm_lease_device_destructor (struct wl_resource *resource)
+{
+  MetaWaylandDrmLeaseDevice *lease_device =
+    wl_resource_get_user_data (resource);
+
+  lease_device->resources = g_list_remove (lease_device->resources, resource);
+  meta_wayland_drm_lease_device_release (lease_device);
+}
+
+static void
+lease_device_bind (struct wl_client *client,
+                   void             *user_data,
+                   uint32_t          version,
+                   uint32_t          id)
+{
+  MetaWaylandDrmLeaseDevice *lease_device = user_data;
+  struct wl_resource *resource;
+
+  resource = wl_resource_create (client, &wp_drm_lease_device_v1_interface,
+                                 version, id);
+  wl_resource_set_implementation (resource,
+                                  &drm_lease_device_implementation,
+                                  g_rc_box_acquire (lease_device),
+                                  wp_drm_lease_device_destructor);
+
+  lease_device->resources = g_list_prepend (lease_device->resources, resource);
+}
+
+static MetaWaylandDrmLeaseDevice *
+meta_wayland_drm_lease_device_new (MetaWaylandDrmLeaseManager *lease_manager,
+                                   MetaKmsDevice              *kms_device)
+{
+  struct wl_display *wayland_display =
+    meta_wayland_compositor_get_wayland_display (lease_manager->compositor);
+  MetaWaylandDrmLeaseDevice *lease_device;
+
+  lease_device = g_rc_box_new0 (MetaWaylandDrmLeaseDevice);
+  lease_device->lease_manager = lease_manager;
+  lease_device->kms_device = kms_device;
+  lease_device->global = wl_global_create (wayland_display,
+                                           &wp_drm_lease_device_v1_interface,
+                                           META_WP_DRM_LEASE_DEVICE_V1_VERSION,
+                                           lease_device,
+                                           lease_device_bind);
+
+  return lease_device;
+}
+
+static void
+meta_wayland_drm_lease_manager_add_device (MetaKmsDevice              *kms_device,
+                                           MetaWaylandDrmLeaseManager *lease_manager)
+{
+  MetaWaylandDrmLeaseDevice *lease_device;
+
+  lease_device = meta_wayland_drm_lease_device_new (lease_manager, kms_device);
+  g_hash_table_insert (lease_manager->devices,
+                       kms_device,
+                       g_steal_pointer (&lease_device));
+}
+
+MetaWaylandDrmLeaseManager *
+meta_wayland_drm_lease_manager_new (MetaWaylandCompositor *compositor)
+{
+  MetaContext *context = meta_wayland_compositor_get_context (compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaBackendNative *backend_native;
+  MetaKms *kms;
+  MetaWaylandDrmLeaseManager *lease_manager;
+
+  if (!META_IS_BACKEND_NATIVE (backend))
+    return NULL;
+
+  backend_native = META_BACKEND_NATIVE (backend);
+  kms = meta_backend_native_get_kms (backend_native);
+
+  lease_manager = g_new0 (MetaWaylandDrmLeaseManager, 1);
+  lease_manager->compositor = compositor;
+  lease_manager->devices =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) meta_wayland_drm_lease_device_release);
+
+  g_list_foreach (meta_kms_get_devices (kms),
+                  (GFunc) meta_wayland_drm_lease_manager_add_device,
+                  lease_manager);
+
+  return lease_manager;
+}
+
+void
+meta_wayland_drm_lease_manager_free (MetaWaylandDrmLeaseManager *lease_manager)
+{
+  g_clear_pointer (&lease_manager->devices, g_hash_table_unref);
+  g_free (lease_manager);
+}
diff --git a/src/wayland/meta-wayland-drm-lease.h b/src/wayland/meta-wayland-drm-lease.h
new file mode 100644
index 000000000..2b6598bdc
--- /dev/null
+++ b/src/wayland/meta-wayland-drm-lease.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2021 Red Hat Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ */
+
+#pragma once
+
+#include "wayland/meta-wayland-types.h"
+
+MetaWaylandDrmLeaseManager * meta_wayland_drm_lease_manager_new (MetaWaylandCompositor *compositor);
+
+void meta_wayland_drm_lease_manager_free (MetaWaylandDrmLeaseManager *lease_manager);
diff --git a/src/wayland/meta-wayland-types.h b/src/wayland/meta-wayland-types.h
index 4f224a900..99b2dc5ad 100644
--- a/src/wayland/meta-wayland-types.h
+++ b/src/wayland/meta-wayland-types.h
@@ -71,3 +71,5 @@ typedef struct _MetaWaylandXdgForeign MetaWaylandXdgForeign;
 typedef struct _MetaWaylandFilterManager MetaWaylandFilterManager;
 
 typedef struct _MetaWaylandClient MetaWaylandClient;
+
+typedef struct _MetaWaylandDrmLeaseManager MetaWaylandDrmLeaseManager;
diff --git a/src/wayland/meta-wayland-versions.h b/src/wayland/meta-wayland-versions.h
index 900f30d78..ec9b93acd 100644
--- a/src/wayland/meta-wayland-versions.h
+++ b/src/wayland/meta-wayland-versions.h
@@ -57,3 +57,4 @@
 #define META_WP_SINGLE_PIXEL_BUFFER_V1_VERSION 1
 #define META_MUTTER_X11_INTEROP_VERSION 1
 #define META_WP_FRACTIONAL_SCALE_VERSION 1
+#define META_WP_DRM_LEASE_DEVICE_V1_VERSION 1
-- 
2.45.0


From ad2f4c79e4040c153c1f33661c96e92ed8f8b0d2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Exp=C3=B3sito?= <jexposit@redhat.com>
Date: Tue, 23 Apr 2024 17:00:38 +0200
Subject: [PATCH 38/44] wayland/drm-lease: Send non-master DRM fd

Some time after a client binds to the wp_drm_lease_device_v1 global,
send a drm_fd event.
---
 src/wayland/meta-wayland-drm-lease.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index 46da3b153..56491974b 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -87,6 +87,27 @@ static const struct wp_drm_lease_device_v1_interface drm_lease_device_implementa
   wp_drm_lease_device_release,
 };
 
+static void
+send_drm_fd (struct wl_client          *client,
+             MetaWaylandDrmLeaseDevice *lease_device,
+             struct wl_resource        *device_resource)
+{
+  int fd;
+  MetaKmsImplDevice *impl_device;
+
+  impl_device = meta_kms_device_get_impl_device (lease_device->kms_device);
+  fd = meta_kms_impl_device_get_non_master_fd (impl_device);
+  if (fd < 0)
+    {
+      wl_client_post_implementation_error (client,
+                                           "Error getting DRM lease device fd");
+      return;
+    }
+
+  wp_drm_lease_device_v1_send_drm_fd (device_resource, fd);
+  close (fd);
+}
+
 static void
 wp_drm_lease_device_destructor (struct wl_resource *resource)
 {
@@ -113,6 +134,9 @@ lease_device_bind (struct wl_client *client,
                                   g_rc_box_acquire (lease_device),
                                   wp_drm_lease_device_destructor);
 
+  send_drm_fd (client, lease_device, resource);
+  wp_drm_lease_device_v1_send_done (resource);
+
   lease_device->resources = g_list_prepend (lease_device->resources, resource);
 }
 
-- 
2.45.0


From fc1de4ea00249ca1210f531e843053b0b93c3922 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 23 Apr 2024 17:55:55 +0200
Subject: [PATCH 39/44] wayland/drm-lease: Advertize initial connectors
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

After sending the drm_fd event, send zero, one or more connector events.
After all currently available connectors have been sent, send a
wp_drm_lease_device_v1.done event.

Co-authored-by: José Expósito <jexposit@redhat.com>
---
 src/wayland/meta-wayland-drm-lease.c | 178 +++++++++++++++++++++++++++
 1 file changed, 178 insertions(+)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index 56491974b..59810cec0 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -54,12 +54,28 @@ typedef struct _MetaWaylandDrmLeaseDevice
   struct wl_global *global;
   MetaKmsDevice *kms_device;
 
+  /* Key:   MetaKmsConnector *kms_connector
+   * Value: MetaWaylandDrmLeaseConnector *lease_connector
+   */
+  GHashTable *connectors;
+
   GList *resources;
 } MetaWaylandDrmLeaseDevice;
 
+typedef struct _MetaWaylandDrmLeaseConnector
+{
+  MetaWaylandDrmLeaseDevice *lease_device;
+
+  MetaKmsConnector *kms_connector;
+  char *description;
+
+  GList *resources;
+} MetaWaylandDrmLeaseConnector;
+
 static void
 meta_wayland_drm_lease_device_free (MetaWaylandDrmLeaseDevice *lease_device)
 {
+  g_clear_pointer (&lease_device->connectors, g_hash_table_unref);
 }
 
 static void
@@ -69,6 +85,20 @@ meta_wayland_drm_lease_device_release (MetaWaylandDrmLeaseDevice *lease_device)
                          (GDestroyNotify) meta_wayland_drm_lease_device_free);
 }
 
+static void
+meta_wayland_drm_lease_connector_free (MetaWaylandDrmLeaseConnector *lease_connector)
+{
+  g_free (lease_connector->description);
+  meta_wayland_drm_lease_device_release (lease_connector->lease_device);
+}
+
+static void
+meta_wayland_drm_lease_connector_release (MetaWaylandDrmLeaseConnector *lease_connector)
+{
+  g_rc_box_release_full (lease_connector,
+                         (GDestroyNotify) meta_wayland_drm_lease_connector_free);
+}
+
 static void
 wp_drm_lease_device_create_lease_request (struct wl_client   *client,
                                           struct wl_resource *resource,
@@ -87,6 +117,127 @@ static const struct wp_drm_lease_device_v1_interface drm_lease_device_implementa
   wp_drm_lease_device_release,
 };
 
+static MetaWaylandDrmLeaseConnector *
+meta_wayland_drm_lease_connector_new (MetaWaylandDrmLeaseDevice *lease_device,
+                                      MetaKmsConnector          *kms_connector)
+{
+  MetaWaylandDrmLeaseConnector *lease_connector;
+  const MetaKmsConnectorState *connector_state;
+
+  lease_connector = g_rc_box_new0 (MetaWaylandDrmLeaseConnector);
+  lease_connector->lease_device = g_rc_box_acquire (lease_device);
+  lease_connector->kms_connector = kms_connector;
+
+  connector_state = meta_kms_connector_get_current_state (kms_connector);
+  if (connector_state->edid_data)
+    {
+      gconstpointer edid_data;
+      g_autofree MetaEdidInfo *edid_info = NULL;
+      size_t edid_size;
+      g_autofree char *vendor = NULL;
+      g_autofree char *product = NULL;
+      GString *description;
+
+      edid_data = g_bytes_get_data (connector_state->edid_data, &edid_size);
+      edid_info = meta_edid_info_new_parse (edid_data, edid_size);
+
+      description = g_string_new (NULL);
+
+      vendor = g_strndup (edid_info->manufacturer_code, 4);
+      if (vendor && g_utf8_validate (vendor, -1, NULL))
+        g_string_append_printf (description, "%s", vendor);
+
+      product = g_strndup (edid_info->dsc_product_name, 14);
+      if (product && g_utf8_validate (product, -1, NULL))
+        {
+          if (description->len > 0)
+            g_string_append_c (description, ' ');
+          g_string_append_printf (description, "%s", product);
+        }
+
+      if (description->len == 0)
+        {
+          g_string_append_printf (description, "%s",
+                                  meta_kms_connector_get_name (kms_connector));
+        }
+
+      lease_connector->description = g_string_free (description, FALSE);
+    }
+  else
+    {
+      lease_connector->description = g_strdup ("");
+    }
+
+  return lease_connector;
+}
+
+static void
+drm_lease_connector_destroy (struct wl_client   *client,
+                             struct wl_resource *resource)
+{
+}
+
+static const struct wp_drm_lease_connector_v1_interface drm_lease_connector_implementation = {
+  drm_lease_connector_destroy,
+};
+
+static void
+wp_drm_lease_connector_destructor (struct wl_resource *resource)
+{
+  MetaWaylandDrmLeaseConnector *lease_connector =
+    wl_resource_get_user_data (resource);
+
+  lease_connector->resources = g_list_remove (lease_connector->resources,
+                                              resource);
+  meta_wayland_drm_lease_connector_release (lease_connector);
+}
+
+static void
+send_new_connector_resource (MetaWaylandDrmLeaseDevice    *lease_device,
+                             struct wl_resource           *device_resource,
+                             MetaWaylandDrmLeaseConnector *lease_connector)
+{
+  struct wl_resource *connector_resource;
+  const char *connector_name;
+  uint32_t connector_id;
+
+  connector_resource =
+    wl_resource_create (wl_resource_get_client (device_resource),
+                        &wp_drm_lease_connector_v1_interface,
+                        wl_resource_get_version (device_resource),
+                        0);
+  wl_resource_set_implementation (connector_resource,
+                                  &drm_lease_connector_implementation,
+                                  g_rc_box_acquire (lease_connector),
+                                  wp_drm_lease_connector_destructor);
+
+  lease_connector->resources = g_list_append (lease_connector->resources,
+                                              connector_resource);
+
+  connector_name = meta_kms_connector_get_name (lease_connector->kms_connector);
+  connector_id = meta_kms_connector_get_id (lease_connector->kms_connector);
+
+  wp_drm_lease_device_v1_send_connector (device_resource, connector_resource);
+  wp_drm_lease_connector_v1_send_name (connector_resource, connector_name);
+  wp_drm_lease_connector_v1_send_description (connector_resource,
+                                              lease_connector->description);
+  wp_drm_lease_connector_v1_send_connector_id (connector_resource,
+                                               connector_id);
+  wp_drm_lease_connector_v1_send_done (connector_resource);
+}
+
+static void
+send_connectors (MetaWaylandDrmLeaseDevice *lease_device,
+                 struct wl_resource        *device_resource)
+{
+  GHashTableIter iter;
+  MetaWaylandDrmLeaseConnector *lease_connector;
+
+  g_hash_table_iter_init (&iter, lease_device->connectors);
+  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_connector))
+    send_new_connector_resource (lease_device, device_resource, lease_connector);
+}
+
 static void
 send_drm_fd (struct wl_client          *client,
              MetaWaylandDrmLeaseDevice *lease_device,
@@ -135,11 +286,28 @@ lease_device_bind (struct wl_client *client,
                                   wp_drm_lease_device_destructor);
 
   send_drm_fd (client, lease_device, resource);
+  send_connectors (lease_device, resource);
   wp_drm_lease_device_v1_send_done (resource);
 
   lease_device->resources = g_list_prepend (lease_device->resources, resource);
 }
 
+static void
+meta_wayland_drm_lease_device_add_connector (MetaKmsConnector          *kms_connector,
+                                             MetaWaylandDrmLeaseDevice *lease_device)
+{
+  MetaWaylandDrmLeaseConnector *lease_connector;
+
+  if (!meta_kms_connector_is_for_lease (kms_connector))
+    return;
+
+  lease_connector = meta_wayland_drm_lease_connector_new (lease_device,
+                                                          kms_connector);
+  g_hash_table_insert (lease_device->connectors,
+                       kms_connector,
+                       g_steal_pointer (&lease_connector));
+}
+
 static MetaWaylandDrmLeaseDevice *
 meta_wayland_drm_lease_device_new (MetaWaylandDrmLeaseManager *lease_manager,
                                    MetaKmsDevice              *kms_device)
@@ -151,6 +319,16 @@ meta_wayland_drm_lease_device_new (MetaWaylandDrmLeaseManager *lease_manager,
   lease_device = g_rc_box_new0 (MetaWaylandDrmLeaseDevice);
   lease_device->lease_manager = lease_manager;
   lease_device->kms_device = kms_device;
+
+  lease_device->connectors =
+    g_hash_table_new_full (NULL, NULL,
+                           NULL,
+                           (GDestroyNotify) meta_wayland_drm_lease_connector_release);
+
+  g_list_foreach (meta_kms_device_get_connectors (kms_device),
+                  (GFunc) meta_wayland_drm_lease_device_add_connector,
+                  lease_device);
+
   lease_device->global = wl_global_create (wayland_display,
                                            &wp_drm_lease_device_v1_interface,
                                            META_WP_DRM_LEASE_DEVICE_V1_VERSION,
-- 
2.45.0


From e67137879de94f30fa1ea660b1dbb7354881fb1b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Wed, 24 Apr 2024 11:15:50 +0200
Subject: [PATCH 40/44] wayland/drm-lease: Update available connectors
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When the list of connectors available for lease changes send
wp_drm_lease_device_v1.connector events for added connectors and
wp_drm_lease_connector_v1.withdrawn events for removed connectors,
followed by a wp_drm_lease_device_v1.done event.

Co-authored-by: José Expósito <jexposit@redhat.com>
---
 src/wayland/meta-wayland-drm-lease.c | 100 +++++++++++++++++++++++++++
 1 file changed, 100 insertions(+)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index 59810cec0..865cc3e86 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -171,10 +171,25 @@ meta_wayland_drm_lease_connector_new (MetaWaylandDrmLeaseDevice *lease_device,
   return lease_connector;
 }
 
+static void
+meta_wayland_drm_lease_connector_send_withdrawn (MetaWaylandDrmLeaseConnector *lease_connector)
+{
+  GList *l;
+
+  for (l = lease_connector->resources; l; l = l->next)
+    {
+      struct wl_resource *resource = l->data;
+
+      if (wl_resource_get_user_data (resource) == lease_connector)
+        wp_drm_lease_connector_v1_send_withdrawn (resource);
+    }
+}
+
 static void
 drm_lease_connector_destroy (struct wl_client   *client,
                              struct wl_resource *resource)
 {
+  wl_resource_destroy (resource);
 }
 
 static const struct wp_drm_lease_connector_v1_interface drm_lease_connector_implementation = {
@@ -308,6 +323,71 @@ meta_wayland_drm_lease_device_add_connector (MetaKmsConnector          *kms_conn
                        g_steal_pointer (&lease_connector));
 }
 
+static void
+meta_wayland_drm_lease_device_update_connectors (MetaWaylandDrmLeaseDevice *lease_device)
+{
+  GList *kms_connectors;
+  GList *l;
+  GHashTable *new_connectors;
+  MetaWaylandDrmLeaseConnector *lease_connector;
+  GHashTableIter iter;
+  gboolean needs_done = FALSE;
+
+  new_connectors = g_hash_table_new_similar (lease_device->connectors);
+
+  kms_connectors = meta_kms_device_get_connectors (lease_device->kms_device);
+  for (l = kms_connectors; l; l = l->next)
+    {
+      MetaKmsConnector *kms_connector = l->data;
+
+      if (!meta_kms_connector_is_for_lease (kms_connector))
+        continue;
+
+      if (!g_hash_table_steal_extended (lease_device->connectors,
+                                        kms_connector,
+                                        NULL,
+                                        (gpointer *) &lease_connector))
+        {
+          GList *lc;
+
+          lease_connector =
+            meta_wayland_drm_lease_connector_new (lease_device, kms_connector);
+
+          for (lc = lease_device->resources; lc; lc = lc->next)
+            {
+              struct wl_resource *resource = lc->data;
+
+              if (wl_resource_get_user_data (resource) == lease_device)
+                {
+                  send_new_connector_resource (lease_device,
+                                               resource,
+                                               lease_connector);
+                  needs_done = TRUE;
+                }
+            }
+        }
+
+      g_hash_table_insert (new_connectors, kms_connector, lease_connector);
+    }
+
+  g_hash_table_iter_init (&iter, lease_device->connectors);
+  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_connector))
+    {
+      needs_done = TRUE;
+      meta_wayland_drm_lease_connector_send_withdrawn (lease_connector);
+    }
+
+  if (needs_done)
+    {
+      g_list_foreach (lease_device->resources,
+                      (GFunc) wp_drm_lease_device_v1_send_done,
+                      NULL);
+    }
+
+  g_hash_table_unref (lease_device->connectors);
+  lease_device->connectors = new_connectors;
+}
+
 static MetaWaylandDrmLeaseDevice *
 meta_wayland_drm_lease_device_new (MetaWaylandDrmLeaseManager *lease_manager,
                                    MetaKmsDevice              *kms_device)
@@ -350,6 +430,22 @@ meta_wayland_drm_lease_manager_add_device (MetaKmsDevice              *kms_devic
                        g_steal_pointer (&lease_device));
 }
 
+static void
+on_resources_changed (MetaKms                    *kms,
+                      MetaKmsResourceChanges      changes,
+                      MetaWaylandDrmLeaseManager *lease_manager)
+{
+  GHashTableIter iter;
+  MetaWaylandDrmLeaseDevice *lease_device;
+
+  if (changes != META_KMS_RESOURCE_CHANGE_FULL)
+    return;
+
+  g_hash_table_iter_init (&iter, lease_manager->devices);
+  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_device))
+    meta_wayland_drm_lease_device_update_connectors (lease_device);
+}
+
 MetaWaylandDrmLeaseManager *
 meta_wayland_drm_lease_manager_new (MetaWaylandCompositor *compositor)
 {
@@ -376,6 +472,10 @@ meta_wayland_drm_lease_manager_new (MetaWaylandCompositor *compositor)
                   (GFunc) meta_wayland_drm_lease_manager_add_device,
                   lease_manager);
 
+  g_signal_connect (kms, "resources-changed",
+                    G_CALLBACK (on_resources_changed),
+                    lease_manager);
+
   return lease_manager;
 }
 
-- 
2.45.0


From 8a80ca4056a73fdb14425266ffc6504ad1ef54f9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 7 May 2024 14:14:00 +0200
Subject: [PATCH 41/44] wayland/drm-lease: Update available devices
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When a new device is connected, register a new global for it.

When a device is gone, remove the global. Upon receiving this event,
the client should destroy any matching wp_drm_lease_device_v1 object.

To destroy a wp_drm_lease_device_v1 object, the client must first
issue a release request. Upon receiving this request, send a released
event and destroy the object.

Co-authored-by: José Expósito <jexposit@redhat.com>
---
 src/wayland/meta-wayland-drm-lease.c | 41 ++++++++++++++++++++++++++++
 1 file changed, 41 insertions(+)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index 865cc3e86..f68b2f8b0 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -110,6 +110,8 @@ static void
 wp_drm_lease_device_release (struct wl_client   *client,
                              struct wl_resource *resource)
 {
+  wp_drm_lease_device_v1_send_released (resource);
+  wl_resource_destroy (resource);
 }
 
 static const struct wp_drm_lease_device_v1_interface drm_lease_device_implementation = {
@@ -430,6 +432,43 @@ meta_wayland_drm_lease_manager_add_device (MetaKmsDevice              *kms_devic
                        g_steal_pointer (&lease_device));
 }
 
+static void
+meta_wayland_drm_lease_update_devices (MetaKms                    *kms,
+                                       MetaWaylandDrmLeaseManager *lease_manager)
+{
+  GList *kms_devices;
+  GList *l;
+  GHashTable *new_devices;
+  MetaWaylandDrmLeaseDevice *lease_device;
+  GHashTableIter iter;
+
+  new_devices = g_hash_table_new_similar (lease_manager->devices);
+
+  kms_devices = meta_kms_get_devices (kms);
+  for (l = kms_devices; l; l = l->next)
+    {
+      MetaKmsDevice *kms_device = l->data;
+
+      if (!g_hash_table_steal_extended (lease_manager->devices,
+                                        kms_device,
+                                        NULL,
+                                        (gpointer *) &lease_device))
+        {
+          lease_device =
+            meta_wayland_drm_lease_device_new (lease_manager, kms_device);
+        }
+
+      g_hash_table_insert (new_devices, kms_device, lease_device);
+    }
+
+  g_hash_table_iter_init (&iter, lease_manager->devices);
+  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_device))
+    wl_global_remove (lease_device->global);
+
+  g_hash_table_unref (lease_manager->devices);
+  lease_manager->devices = new_devices;
+}
+
 static void
 on_resources_changed (MetaKms                    *kms,
                       MetaKmsResourceChanges      changes,
@@ -441,6 +480,8 @@ on_resources_changed (MetaKms                    *kms,
   if (changes != META_KMS_RESOURCE_CHANGE_FULL)
     return;
 
+  meta_wayland_drm_lease_update_devices (kms, lease_manager);
+
   g_hash_table_iter_init (&iter, lease_manager->devices);
   while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_device))
     meta_wayland_drm_lease_device_update_connectors (lease_device);
-- 
2.45.0


From 7356e74366581987e317fa6d9c1611130c64348e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 7 May 2024 18:22:18 +0200
Subject: [PATCH 42/44] wayland/drm-lease: Handle DRM lease requests
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When a client wants to lease DRM resources, it will attach the list of
connectors is wants to lease and then submit the request.
Once the request is submitted, destroy the DRM lease request object.

Co-authored-by: José Expósito <jexposit@redhat.com>
---
 src/wayland/meta-wayland-drm-lease.c | 89 ++++++++++++++++++++++++++++
 1 file changed, 89 insertions(+)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index f68b2f8b0..e296a56b3 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -72,6 +72,13 @@ typedef struct _MetaWaylandDrmLeaseConnector
   GList *resources;
 } MetaWaylandDrmLeaseConnector;
 
+typedef struct _MetaWaylandDrmLeaseRequest
+{
+  MetaWaylandDrmLeaseDevice *lease_device;
+  GList *lease_connectors;
+  struct wl_resource *resource;
+} MetaWaylandDrmLeaseRequest;
+
 static void
 meta_wayland_drm_lease_device_free (MetaWaylandDrmLeaseDevice *lease_device)
 {
@@ -99,11 +106,93 @@ meta_wayland_drm_lease_connector_release (MetaWaylandDrmLeaseConnector *lease_co
                          (GDestroyNotify) meta_wayland_drm_lease_connector_free);
 }
 
+static void
+wp_drm_lease_request_request_connector (struct wl_client   *client,
+                                        struct wl_resource *resource,
+                                        struct wl_resource *connector)
+{
+  MetaWaylandDrmLeaseRequest *lease_request =
+    wl_resource_get_user_data (resource);
+  MetaWaylandDrmLeaseConnector *lease_connector =
+    wl_resource_get_user_data (connector);
+
+  if (lease_request->lease_device != lease_connector->lease_device)
+    {
+      wl_resource_post_error (resource,
+                              WP_DRM_LEASE_REQUEST_V1_ERROR_WRONG_DEVICE,
+                              "Wrong lease device");
+      return;
+    }
+
+  if (g_list_find (lease_request->lease_connectors, lease_connector))
+    {
+      wl_resource_post_error (resource,
+                              WP_DRM_LEASE_REQUEST_V1_ERROR_DUPLICATE_CONNECTOR,
+                              "Connector requested twice");
+      return;
+    }
+
+  lease_request->lease_connectors =
+    g_list_append (lease_request->lease_connectors,
+                   g_rc_box_acquire (lease_connector));
+}
+
+static void
+wp_drm_lease_request_submit (struct wl_client   *client,
+                             struct wl_resource *resource,
+                             uint32_t            id)
+{
+  MetaWaylandDrmLeaseRequest *lease_request =
+    wl_resource_get_user_data (resource);
+
+  if (!lease_request->lease_connectors)
+    {
+      wl_resource_post_error (resource,
+                              WP_DRM_LEASE_REQUEST_V1_ERROR_EMPTY_LEASE,
+                              "Empty DRM lease request");
+      return;
+    }
+
+  wl_resource_destroy (resource);
+}
+
+static const struct wp_drm_lease_request_v1_interface drm_lease_request_implementation = {
+  wp_drm_lease_request_request_connector,
+  wp_drm_lease_request_submit,
+};
+
+static void
+wp_drm_lease_request_destructor (struct wl_resource *resource)
+{
+  MetaWaylandDrmLeaseRequest *lease_request =
+    wl_resource_get_user_data (resource);
+
+  meta_wayland_drm_lease_device_release (lease_request->lease_device);
+  g_list_foreach (lease_request->lease_connectors,
+                  (GFunc) meta_wayland_drm_lease_connector_release,
+                  NULL);
+  g_free (lease_request);
+}
+
 static void
 wp_drm_lease_device_create_lease_request (struct wl_client   *client,
                                           struct wl_resource *resource,
                                           uint32_t            id)
 {
+  MetaWaylandDrmLeaseDevice *lease_device =
+    wl_resource_get_user_data (resource);
+  MetaWaylandDrmLeaseRequest *lease_request;
+
+  lease_request = g_new0 (MetaWaylandDrmLeaseRequest, 1);
+  lease_request->lease_device = g_rc_box_acquire (lease_device);
+  lease_request->resource =
+    wl_resource_create (client, &wp_drm_lease_request_v1_interface,
+                        wl_resource_get_version (resource), id);
+
+  wl_resource_set_implementation (lease_request->resource,
+                                  &drm_lease_request_implementation,
+                                  lease_request,
+                                  wp_drm_lease_request_destructor);
 }
 
 static void
-- 
2.45.0


From 695d196a4f8ef31b991a4e3322e0ae646b962e50 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Exp=C3=B3sito?= <jexposit@redhat.com>
Date: Wed, 8 May 2024 17:48:42 +0200
Subject: [PATCH 43/44] wayland/drm-lease: Lease requested resources

When a lease request is received, validate it and lease the requested
resources.

When a connector or device is hot-unplugged, revoke the lease and send a
lease finish event to the client.
---
 src/wayland/meta-wayland-drm-lease.c | 197 ++++++++++++++++++++++++++-
 1 file changed, 196 insertions(+), 1 deletion(-)

diff --git a/src/wayland/meta-wayland-drm-lease.c b/src/wayland/meta-wayland-drm-lease.c
index e296a56b3..5bafc5b18 100644
--- a/src/wayland/meta-wayland-drm-lease.c
+++ b/src/wayland/meta-wayland-drm-lease.c
@@ -31,6 +31,7 @@
 #include "backends/native/meta-kms-device.h"
 #include "backends/native/meta-kms-device-private.h"
 #include "backends/native/meta-kms-impl-device.h"
+#include "backends/native/meta-kms-lease.h"
 #include "backends/native/meta-kms.h"
 #include "backends/edid.h"
 #include "wayland/meta-wayland-private.h"
@@ -40,11 +41,14 @@
 struct _MetaWaylandDrmLeaseManager
 {
   MetaWaylandCompositor *compositor;
+  MetaKmsLeaseManager *kms_lease_manager;
 
   /* Key:   MetaKmsDevice *kms_device
    * Value: MetaWaylandDrmLeaseDevice *lease_device
    */
   GHashTable *devices;
+
+  GList *leases;
 };
 
 typedef struct _MetaWaylandDrmLeaseDevice
@@ -79,6 +83,15 @@ typedef struct _MetaWaylandDrmLeaseRequest
   struct wl_resource *resource;
 } MetaWaylandDrmLeaseRequest;
 
+typedef struct _MetaWaylandDrmLease
+{
+  MetaWaylandDrmLeaseManager *lease_manager;
+  MetaWaylandDrmLeaseDevice *lease_device;
+  GList *lease_connectors;
+  uint32_t lessee_id;
+  struct wl_resource *resource;
+} MetaWaylandDrmLease;
+
 static void
 meta_wayland_drm_lease_device_free (MetaWaylandDrmLeaseDevice *lease_device)
 {
@@ -106,6 +119,79 @@ meta_wayland_drm_lease_connector_release (MetaWaylandDrmLeaseConnector *lease_co
                          (GDestroyNotify) meta_wayland_drm_lease_connector_free);
 }
 
+static void
+meta_wayland_drm_lease_free (MetaWaylandDrmLease *lease)
+{
+  meta_wayland_drm_lease_device_release (lease->lease_device);
+  g_list_foreach (lease->lease_connectors,
+                  (GFunc) meta_wayland_drm_lease_connector_release,
+                  NULL);
+}
+
+static void
+meta_wayland_drm_lease_release (MetaWaylandDrmLease *lease)
+{
+  g_rc_box_release_full (lease, (GDestroyNotify) meta_wayland_drm_lease_free);
+}
+
+static gboolean
+meta_wayland_drm_has_active_leases (GList *leases)
+{
+  GList *l;
+
+  for (l = leases; l; l = l->next)
+    {
+      MetaWaylandDrmLease *lease = l->data;
+      MetaKmsLease *kms_lease =
+        meta_kms_lease_manager_get_lease_from_id (lease->lease_manager->kms_lease_manager,
+                                                  lease->lessee_id);
+
+      if (kms_lease && meta_kms_lease_is_active (kms_lease))
+        return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void
+meta_wayland_drm_lease_revoke (MetaWaylandDrmLease *lease)
+{
+  MetaKmsLease *kms_lease =
+    meta_kms_lease_manager_get_lease_from_id (lease->lease_manager->kms_lease_manager,
+                                              lease->lessee_id);
+
+  if (kms_lease)
+    {
+      meta_kms_lease_revoke (kms_lease);
+      wp_drm_lease_v1_send_finished (lease->resource);
+    }
+}
+
+static void
+wp_drm_lease_destroy (struct wl_client   *client,
+                      struct wl_resource *resource)
+{
+  MetaWaylandDrmLease *lease = wl_resource_get_user_data (resource);
+
+  meta_wayland_drm_lease_revoke (lease);
+
+  wl_resource_destroy (resource);
+}
+
+static const struct wp_drm_lease_v1_interface drm_lease_implementation = {
+  wp_drm_lease_destroy,
+};
+
+static void
+wp_drm_lease_destructor (struct wl_resource *resource)
+{
+  MetaWaylandDrmLease *lease = wl_resource_get_user_data (resource);
+
+  lease->lease_manager->leases = g_list_remove (lease->lease_manager->leases,
+                                                lease);
+  meta_wayland_drm_lease_release (lease);
+}
+
 static void
 wp_drm_lease_request_request_connector (struct wl_client   *client,
                                         struct wl_resource *resource,
@@ -144,6 +230,18 @@ wp_drm_lease_request_submit (struct wl_client   *client,
 {
   MetaWaylandDrmLeaseRequest *lease_request =
     wl_resource_get_user_data (resource);
+  MetaWaylandDrmLeaseDevice *lease_device = lease_request->lease_device;
+  MetaWaylandDrmLeaseManager *lease_manager = lease_device->lease_manager;
+  GHashTable *available_devices = lease_manager->devices;
+  GHashTable *available_connectors = lease_device->connectors;
+  MetaKmsDevice *kms_device = lease_device->kms_device;
+  MetaKmsLeaseManager *kms_lease_manager = lease_manager->kms_lease_manager;
+  MetaWaylandDrmLease *lease;
+  g_autoptr (GList) connectors = NULL;
+  g_autoptr (MetaKmsLease) kms_lease = NULL;
+  g_autoptr (GError) error = NULL;
+  int fd = -1;
+  GList *l;
 
   if (!lease_request->lease_connectors)
     {
@@ -153,6 +251,76 @@ wp_drm_lease_request_submit (struct wl_client   *client,
       return;
     }
 
+  lease = g_rc_box_new0 (MetaWaylandDrmLease);
+  lease->lease_manager = lease_manager;
+  lease->lease_device = g_rc_box_acquire (lease_device);
+  lease->resource =
+    wl_resource_create (client, &wp_drm_lease_v1_interface,
+                        wl_resource_get_version (resource), id);
+
+  wl_resource_set_implementation (lease->resource,
+                                  &drm_lease_implementation,
+                                  lease,
+                                  wp_drm_lease_destructor);
+
+  lease_manager->leases = g_list_append (lease_manager->leases, lease);
+
+  if (meta_wayland_drm_has_active_leases (lease_manager->leases))
+    {
+      g_warning ("Another lease is active at the moment");
+      goto reject_request;
+    }
+
+  if (!g_hash_table_contains (available_devices, kms_device))
+    {
+      g_warning ("KMS device %s is not available",
+                 meta_kms_device_get_path (kms_device));
+      goto reject_request;
+    }
+
+  for (l = lease_request->lease_connectors; l; l = l->next)
+    {
+      MetaWaylandDrmLeaseConnector *lease_connector = l->data;
+      MetaKmsConnector *kms_connector = lease_connector->kms_connector;
+
+      if (!g_hash_table_contains (available_connectors, kms_connector))
+        {
+          g_warning ("KMS connector %u (%s) is not available",
+                     meta_kms_connector_get_id (kms_connector),
+                     meta_kms_device_get_path (kms_device));
+          goto reject_request;
+        }
+
+      lease->lease_connectors =
+        g_list_append (lease->lease_connectors,
+                       g_rc_box_acquire (lease_connector));
+      connectors = g_list_append (connectors, kms_connector);
+    }
+
+  kms_lease = meta_kms_lease_manager_lease_connectors (kms_lease_manager,
+                                                       connectors,
+                                                       &error);
+  if (!kms_lease)
+    {
+      g_warning ("Failed to create lease from connector list: %s",
+                 error->message);
+      goto reject_request;
+    }
+
+  fd = meta_kms_lease_steal_fd (kms_lease);
+  wp_drm_lease_v1_send_lease_fd (lease->resource, fd);
+
+  lease->lessee_id = meta_kms_lease_get_id (kms_lease);
+
+  goto clean;
+
+reject_request:
+  wp_drm_lease_v1_send_finished (lease->resource);
+
+clean:
+  if (fd != -1)
+    close (fd);
+
   wl_resource_destroy (resource);
 }
 
@@ -465,6 +633,15 @@ meta_wayland_drm_lease_device_update_connectors (MetaWaylandDrmLeaseDevice *leas
   while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_connector))
     {
       needs_done = TRUE;
+
+      for (l = lease_device->lease_manager->leases; l; l = l->next)
+        {
+          MetaWaylandDrmLease *lease = l->data;
+
+          if (g_list_find (lease->lease_connectors, lease_connector))
+            meta_wayland_drm_lease_revoke (lease);
+        }
+
       meta_wayland_drm_lease_connector_send_withdrawn (lease_connector);
     }
 
@@ -552,7 +729,17 @@ meta_wayland_drm_lease_update_devices (MetaKms                    *kms,
 
   g_hash_table_iter_init (&iter, lease_manager->devices);
   while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &lease_device))
-    wl_global_remove (lease_device->global);
+    {
+      for (l = lease_device->lease_manager->leases; l; l = l->next)
+        {
+          MetaWaylandDrmLease *lease = l->data;
+
+          if (lease->lease_device == lease_device)
+            meta_wayland_drm_lease_revoke (lease);
+        }
+
+      wl_global_remove (lease_device->global);
+    }
 
   g_hash_table_unref (lease_manager->devices);
   lease_manager->devices = new_devices;
@@ -593,6 +780,10 @@ meta_wayland_drm_lease_manager_new (MetaWaylandCompositor *compositor)
 
   lease_manager = g_new0 (MetaWaylandDrmLeaseManager, 1);
   lease_manager->compositor = compositor;
+  lease_manager->kms_lease_manager = g_object_new (META_TYPE_KMS_LEASE_MANAGER,
+                                                   "backend-native",
+                                                   backend_native,
+                                                   NULL);
   lease_manager->devices =
     g_hash_table_new_full (NULL, NULL,
                            NULL,
@@ -613,5 +804,9 @@ void
 meta_wayland_drm_lease_manager_free (MetaWaylandDrmLeaseManager *lease_manager)
 {
   g_clear_pointer (&lease_manager->devices, g_hash_table_unref);
+  g_object_unref (lease_manager->kms_lease_manager);
+  g_list_foreach (lease_manager->leases,
+                  (GFunc) meta_wayland_drm_lease_release,
+                  NULL);
   g_free (lease_manager);
 }
-- 
2.45.0


From 352f62d4444f874635b9bed2bb266b9f3da81ed4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jonas=20=C3=85dahl?= <jadahl@gmail.com>
Date: Thu, 9 May 2024 11:39:00 +0200
Subject: [PATCH 44/44] wayland: Add DRM lease manager

Now that all the required pieces to support DRM lease are in place,
expose the protocol.
---
 src/wayland/meta-wayland-private.h |  4 ++++
 src/wayland/meta-wayland.c         | 18 ++++++++++++++++++
 2 files changed, 22 insertions(+)

diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index e8d442c03..b992f3c50 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -111,6 +111,10 @@ struct _MetaWaylandCompositor
    * order they were committed.
    */
   GQueue committed_transactions;
+
+#ifdef HAVE_NATIVE_BACKEND
+  MetaWaylandDrmLeaseManager *lease_manager;
+#endif
 };
 
 gboolean meta_wayland_compositor_is_egl_display_bound (MetaWaylandCompositor *compositor);
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index 501b69a91..4dc930afa 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -69,6 +69,7 @@
 #ifdef HAVE_NATIVE_BACKEND
 #include "backends/native/meta-frame-native.h"
 #include "backends/native/meta-renderer-native.h"
+#include "wayland/meta-wayland-drm-lease.h"
 #endif
 
 enum
@@ -696,6 +697,11 @@ meta_wayland_compositor_finalize (GObject *object)
   g_clear_pointer (&priv->filter_manager, meta_wayland_filter_manager_free);
   g_clear_pointer (&priv->frame_callback_sources, g_hash_table_destroy);
 
+#ifdef HAVE_NATIVE_BACKEND
+  g_clear_pointer (&compositor->lease_manager,
+                   meta_wayland_drm_lease_manager_free);
+#endif
+
   g_clear_pointer (&compositor->display_name, g_free);
   g_clear_pointer (&compositor->wayland_display, wl_display_destroy);
   g_clear_pointer (&compositor->source, g_source_destroy);
@@ -804,6 +810,14 @@ init_dma_buf_support (MetaWaylandCompositor *compositor)
     }
 }
 
+#ifdef HAVE_NATIVE_BACKEND
+static void
+meta_wayland_drm_lease_manager_init (MetaWaylandCompositor *compositor)
+{
+  compositor->lease_manager = meta_wayland_drm_lease_manager_new (compositor);
+}
+#endif /* HAVE_NATIVE_BACKEND */
+
 MetaWaylandCompositor *
 meta_wayland_compositor_new (MetaContext *context)
 {
@@ -871,6 +885,10 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_idle_inhibit_init (compositor);
   meta_wayland_drm_syncobj_init (compositor);
 
+#ifdef HAVE_NATIVE_BACKEND
+  meta_wayland_drm_lease_manager_init (compositor);
+#endif
+
 #ifdef HAVE_WAYLAND_EGLSTREAM
   {
     gboolean should_enable_eglstream_controller = TRUE;
-- 
2.45.0

